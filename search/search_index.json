{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to Chef Bootcamp by School of Devops\n\n\nThis is a Lab Guide which goes along with the Zero to Docker Course by School of Devops. \n\n\nFor information about the devops trainign courses visit \nschoolofdevops.com\n.\n\n\nTeam\n\n\n\n\nGourav Shah\n\n\nMeenachisundaram V", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-chef-bootcamp-by-school-of-devops", 
            "text": "This is a Lab Guide which goes along with the Zero to Docker Course by School of Devops.   For information about the devops trainign courses visit  schoolofdevops.com .", 
            "title": "Welcome to Chef Bootcamp by School of Devops"
        }, 
        {
            "location": "/#team", 
            "text": "Gourav Shah  Meenachisundaram V", 
            "title": "Team"
        }, 
        {
            "location": "/01_introduction/", 
            "text": "How I got started with Puppet, Chef  and Devops ?\n\n\nAs Georg Buchner said:\n\n\n\n\nWe are only puppets, our strings\nare being pulled by unknown forces.\n\n\n\n\nMy journey with Devops began with Puppet ( a tool similar to chef, in fact Chef has  from this) back in 2008, when as I was part of the Ops Team managing web scale infrastructure for a SaaS company. Our team consisted of ops engineers in  India and US working out of  their respective timezones, keeping lights on 24x7.  As part of day to day operations, all of us would  make ad hoc changes to the servers, and not always communicate back with the team on the other side of the globe. We did not have daily sync up meetings either. As a result of this ad hoc, inconsistent setup, regularly, issues would pop up with the product, in pre production/integration as well as in production environments. Being in charge of triaging, my team would  spend a lot of time flipping through logs, doing root cause analysis and  figuring out whether its a problem due to inconsistent configurations or a actual code related issue. Tired of this fire fighting, we started looking for solutions to help us efficiently manage this environment. And thats when we came across Puppet, which was popular, was already picked by likes of google, and had an active community around it. We started using it to setup the infrastructure as well as manage changes through a centralized console.\n\n\nResults were immediate, and tangible. After implementing puppet based configuration management system,\n\n\n\n\n\n\nWe now had a centralized tool which streamlined our process of managing configurations. This resulted in minimal ad hoc changes and \nconsistency\n across the environments.\n\n\n\n\n\n\nVisibility\n was another important outcome. Since we started writing infrastructure as a Code, everyone including the developers had \nvisibility\n into the way infrastructure was configured. All one had to do was look at the svn/git repository, the last commits to know what changes were made, my whom and when. What more, developers could even tweak the application properties in their own integration environments.\n\n\n\n\n\n\nError rates\n, specially related to configurations dropped  significantly, giving us more time back in our day, to focus on scale and other important issues.\n\n\n\n\n\n\nThat was the beginning of my journey with devops automation tools. Even though Puppet was the first kid on the block, Chef, which was released in 2009 has evolved to be a very mature, powerful and flexible automation tool, with a great community built around it.\n\n\nBefore we start looking into what makes puppet a excellent choice for a automation tool, lets first understand what configuration management is about.\n\n\nInfrastructure Life Events and Chef\n\n\nIf you are the one  who is in the business of managing  more than a handful of systems, you should be familiar with the term \"Configuration Management\" (not to confuse with traditional Software Configuration Management or SCM). Be it physical servers, virtual machines or cloud based setup, infrastructure typically goes through the  following life events,\n\n\n\n\n\n\nProvisioning\n\n\nProvision servers - physical, virtual or cloud. This is where the servers are brought into being.\n\n\n\n\nInstall Operating System either using manual/automated install process or using an image/template.\n\n\n\n\n\n\nConfiguration Management\n\n\n\n\nBase Systems Configurations:  Prepare the systems with the base configurations such as users,  packages, security configurations, network setup etc.\n\n\nTech Stack: install and configure services such as apache, tomcat, middle wares, setup cron jobs, install and configure databases etc.\n\n\n\n\nApplication: Deploy the application code on top of the tech stack configured. This is where the code written by your team gets deployed with relevant configurations.\n\n\n\n\n\n\nChange Management\n\n  Configurations made during the initial setup do not remain  do not last for a life time. Infrastructure is in the constant state of flux  and evolves over time. Change management involves,\n\n\n\n\nUpdating configurations parameters across a class of servers eg. update port that web server is running on.\n\n\nDeploying new versions of the application code, push security patches etc, install additional services.\n\n\n\n\nChef serves as a excellent tool for Configuration Management as well as Change Management. And along with tools such as AWS Opsworks, Cloud Plugins, Vagrant, Terraform it could also  automate provisioning of servers too. However chef as a tool by itself does have an ability to provision and comes in to play once the Operating System is installed and chef agent is setup.\n\n\nIf you are looking for a tool which could also provision servers, and do it effectively, you should  consider Ansible.\n\n\nEvolution of Configuration Management\n\n\nThe need for managing configurations and ongoing  changes had been a challenge which has seen various approaches. Lets have a look at the evolution of configuration management,\n\n\nManual\n\n\nAs systems engineers, we almost always begin configuring systems by hand, in a ad hoc manner. This approach is the easiest, and useful when you have only a handful of systems to manage, simple configurations, and where you do not have repeatable tasks or updates. However, as you start growing, this crude approach quickly gets out of control. It also involves manual processes, which mandates a operator to be present, and is prone to errors or omissions.\n\n\nScripts\n\n\nScripts allow one to take a sequence of commands to run and put it in a procedural program. Whenever there is need to repeat the process,  scripts come in very handy. Some of the popular scripting languages amongst the systems personnel include shell/bash, perl, python, ruby or powershell.  Scripts are almost always the first approach towards automating manual tasks. However, scripts are not scalable or flexible enough to manage a sophisticated infrastructure spanning across multitude of environments or the ones involving multiple different operating systems etc.\n\n\nConfiguration Management and  Software Configuration Management\n\n\nSoftware Configuration Management is referred to often with context of\nRevision Control which is about tracking changes to the application code.\nThis is just one part of a larger field of Configuration Management.  \n\n\nGolden Images/ Templates\n\n\nGolden images, or templates, or simply os images, are probably the quickest way to deploy servers complete with configurations, specially in virtual or cloud environments. Images are nothing but pre baked templates with operations system files, applications, and configurations. Take any cloud provider, and one of the first components to choose while you provision a server is the images. A lot of organizations these days package their products in the form of images such as ova, vmdk or even vagrant's box format. However images have one major problem i.e. change management. Every time there is an update, even a single line change,  one needs to build a new image. Not only this complete system image needs to be distributed but also existing systems need to be replaced with the new image. Imagine doing that in a dynamic environment involving frequent updates across  hundreds of servers. That could get too cumbersome. And thats where the need to come up with a new approach.  \n\n\nInfrastructure as a Code\n\n\n\"Infrastructure as a Code\" or \"Programmable Infrastructure\" is where today's generation tools such as Puppet, Chef, Ansible, Salt fit in. These tools essentially allow one to write the state of the infrastructure using a higher level descriptive  language and store it as a code. Since this is a code, one could bring in the best practices that developers have been following for years e.g. using revision control systems, use of sophisticated editors, test driven development, peer programming etc. You could  even build the complete infrastructure from scratch in case of a disaster, as long as you have the code repository, compute resources and data backups in place. Since this code is written in a simple declarative syntax, it is self documenting and offers visibility to all stakeholders into the way infrastructure is built and configured.\n\n\n\n\n\n\n\n\nApproach\n\n\nAdvantages\n\n\nDisadvantages\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nManual\n\n\n\\pbox{5cm}{simple}\n\n\n\\pbox{5cm}{ad hoc, error prone, inconsistent, not repeatable}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nScripts\n\n\n\\pbox{5cm}{repeatable, automated}\n\n\n\\pbox{5cm}{procedural, not scalable, inflexible}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nImages\n\n\n\\pbox{5cm}{repeatable, automated}\n\n\n\\pbox{5cm}{size, change management is not easy}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInfrastructure as a Code\n\n\n\\pbox{5cm}{repeatable, flexible, scalable, automated, consistent}\n\n\n\\pbox{5cm}{agent based, learning curve}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhy to use chef ?\n\n\nNow that we have started discussion on   Infrastructure as a Code, specifically chef, lets discuss about the specific features of chef that make it a useful tool for configuration and change management.\n\n\nDeclarative vs Procedural Approach\n\n\nScripts take a procedural approach towards automation. With scripts, we focus on the \nhow\n part. e.g. how to install a package, how to create a user, how to modify it later, how to do it on a specific platform. And if you would want to add a support for another platform, you may have to add additional procedure and write a conditional to check for the platform and call the relevant code. This involves a lot of efforts.\n\n\nOn the other hand, chef takes a declarative approach towards automation. With chef, our focus changes from   \nhow\n part to \nwhat\n. Instead of writing procedures, we start using a simple declarative syntax to define the desired state of infrastructure.  Let me explain this with an analogy.\n\n\nLets say we want to build a house. When we  set out to do so, we hire a contractor, who in turns has a team of construction workers who know how to build it brick by brick. They do all the hard work to bring our house into a reality. Thats the \nhow\n part.\n\n\nOn the other hand, you have a Architect. Lets take a moment and think about what he or she does. An Architect creates a plan, a blue print, which is nothing but a description of how your house should look like. The architect envisions the end state of your house, thinks about \nwhat\n should it consists of, breaks it down into components,  and starts creating  specification for each. He would then stitch it together to create a blueprint of our house, and hands it to the contractor to go and build it. This is the how part.\n\n\nThats exactly what we would start doing with chef, only difference being, we write the specification for desired state of IT infrastructure.\n\n\nResource Abstraction Layer\n\n\nWe just learnt about chef allowing us to write the desired state of the infrastructure using a descriptive language. Now  this concept is brought into a reality with the its Domain Specific Language(DSL) which consists of a Resource Abstraction Layer (RAL). Lets describe how this works,\n\n\nTODO\n: Create an image for each step below.\n\n\n\n\nchef looks at  infrastructure as a collection of entities to manage e.g. package, service, user, network interface etc.\n\n\nIt then takes the  procedures, the actual logic to manage these entities and  bundles it into something called as \nProviders\n. Providers are platform specific. That way, each entity may have multiple providers e.g. managing user on linux vs osx vs windows.\n\n\nOn top of these procedures, chef creates an abstraction layer. Instead of defining the procedures, it offers the users a simple declarative syntax to define the state of the entity and its properties, in the form of \nResources\n.\n\n\nchef, then does the translation between Resources and Providers, and calls the procedure to put the entity in to the desired state just as described by the user.\n\n\n\n\nThis behavior allows the users of the chef to create policies stating what which entities should be present or absent, with what properties.\n\n\nConvergence and Idempotence\n\n\nchef reads the resources, calls the relevant providers for the platform it runs on, and ensures the desired state of the resource is achieved. While it does so, it may need to make changes to the system. But what if the resource has already achieved the desired state and needs no further updates?  chef has the  built in intelligence to know what is the current state of the resource is. Instead of making changes blindly, it first compares the current state of the resource with the desired state, and the makes a decision whether it requires any changes, and if yes, what changes to make.  This process is called as convergence.\n\n\nTODO\n: Draw diagrams, maybe just a flowchart\n\n\ne.g.\n\n\nLets assume we have written a resource to create  a user  with a password.\n\n\nuser 'xyz' do\n  uid   '501'\n  gid   '501'\n  home  '/home/xyz'\n  password  '$1$foYKL0zO$elXbUOb/JjHqS4aI8O25i.'\nend\n\n\n\n\n\n\n\n\nFirst time chef applies this resource on the system, the user may not exist. chef detects the current state, compares it with the desired state which mentions it should exist, and finds the configuration drift. It then creates the user with the password to bring the current state to desired state.\n\n\n\n\n\n\nLets assume we run chef again to apply the same resource. This time too it will compare the desired state with current state. Since the user is already present with the password provided, it deems no changes necessary. Instead of attempting to create the user again, it will skip the resource and move on to the next one.\n\n\n\n\n\n\nLets assume we updated the password information for the user in our code description of the resource, and excute chef. This time, while comparing the current state with desired state, it detects that the user is present, but the password is updated. It does not attempt to create a user, but only changes one property i.e. password.\n\n\n\n\n\n\nIdempotence is a useful property to  ensures that chef maintains the state of the infrastructure such that its always  in the policy. This also makes change management easier as one could keep running chef as a service which invokes itself at regular intervals, pulls the changes, and apply only what is changed.\n\n\nCentralized Configuration Management System\n\n\nA typical installation of chef involves  a chef Master, which is a centralized management console and Agents runnings on every node managed.  Any changes to nodes have to go through the chef Master. This streamlines the process of pushing updated.  Instead of iterating over a list of hosts using a for loop or other such methods, or logging into each system to make changes, all you need to do is push updates to chef Server, from where those are automatically propogated to the nodes.\n\n\nTODO\n \n\n\nPull Approach\n\n\nWhile chef offers a centralized management approach, it works unlike most client server schemes. Instead of pushing updates to the nodes from master, its the duty of chef agent to go the master,  pull changes, and apply. Pull method offers more flexibility and scalability for the following reasons,\n\n\n\n\n\n\nEach node could decide how frequently or infrequently it should update. Some systems need frequent updates, where as others need not be updated for weeks. This could be controlled at  per client level.\n\n\n\n\n\n\nNo need to manage inventory and connection details on the master. Nodes could come and go, and could be configured based on dynamic rules to classify them based on certain property e.g. host names, environments, or even hardware addresses.\n\n\n\n\n\n\nWith push based approach, master must have a ability reach out and connect to each node managed in order to configure it. A lot of times you may have a master on a cloud or in a separate data center than nodes being managed, which could be behind a firewall or NAT device in a private network. In case of pull method, as long as the master is available on a well known address, and is reachable from the nodes, configurations can be pulled and applied.\n\n\n\n\n\n\nCode vs Data\n\n\nA lot of applications that we configure on our servers are generic eg. apache, tomcat, mysql, mongo. These applications have a install base of hundreds of thousands of servers, used by organizations across the globe. Ever wondered how these become specific to your environment ? Even though you use the same apache web server used by many others, its how you configure it makes the difference. Even in single organization, you may have a apache server which behaves differently in different environment based on the configuration profile created. The process of setting up an application involves,\n\n\n\n\nInstalling the generic application either from a source, package or a repository.\n\n\nAdding data. This where you set configuration parameters  e.g. port, user, max connections, webroot for apache.\n\n\nStart, enable the service.\n\n\n\n\nchef allows separation of  code and data.\n\n\n\n\nUsing chef's DSL, we write infrastructure code to install packages start services etc. Code is generic.\n\n\nchef's attributes templates, along with dat bags and attribute precedence rules provide a way to create different configuration profiles specific to different nodes, environments, platforms etc.\n\n\n\n\nShared Library of Infrastructure Code\n\n\nWith chef's ability to separate code and configuration data, the declarative code that you write in the form of modules with  chef becomes generic enough to be shared and be reused. And since this code is in the version control, hosted services such as github offer the perfect means to publish this code. As you start writing code with chef, you would discover about chef forge, a library of community written modules. At the time of writing, there are more than 4000 modules available on chef forge. Similar to a lot of open source code, you need not re invent the wheel. For most open source applications, you would find very sophisticated modules which you could use without even single line change. Download the modules, install it on your own chef master, add configuration profile, and off you go.\n\n\nCloud Integrations\n\n\nWith emergence of cloud, computing is moving towards the utility model. More and more organizations have already migrated or contemplating to migrate a partial or whole of their computing setup to cloud. And with that happening, which ever automation tool that you would consider, needs to have a close integration with the cloud platform that you plan to use. Provisioning of infrastructure components before chef comes in and starts configuring  There are two ways chef provides a way for this,\n\n\n\n\n\n\nThrough library of custom resources/libraries  which allow one to write provisioning of cloud components in the form of resources.\n\n\n\n\n\n\nCloud specific tools e.g. Cloudformation on AWS or Heat on Openstack are some of the tools which help provision components which are specific to that cloud and then call chef to do the configurations.\n\n\n\n\n\n\nThird party tools such as Vagrant, Terraform have in turn ability to talk to multiple cloud providers. These tools typically provision servers on the cloud and then hand it off to chef for configurations.\n\n\n\n\n\n\nIterative Approach to Automation\n\n\nHowever convinced you are with chef, scrapping  your existing automation tool  overnight for a shiny new tool may have  unknown risks attached. More over, it may could  be challenging  to get a buy in from your management to invest in time, money and resources to implement a new solution without showing them the value.\n\n\nWith chef, you could take a iterative approach towards automation. You could start with a single application, or even a single entity such as a system user to manage. Once you see the value, show it to all stake holders, get a buy in and move to the next application, one at a time.\n\n\nDevice Support\n\n\nManaging configurations on systems running common operating systems such as windows, linux, os x, where chef agent application  can be installed is easy.  Its a completely different beast when it comes to   managing configurations on  devices running their own specialized version of operating systems/firmwares. Examples are configuring CISCO's network switches routers, EMC's storage array.\n\n\nAlong with programmable infrastructures, new concepts such as Software Defined Networking(SDN) and Software Defined Storage(SDS) are taking root and changing the way devices are being managed. chef supports managing devices in two ways,\n\n\n\n\nDevices that are based on linux and have chef agent ported to run on those can be configured the same way as other generic systems.\n\n\nSub set of devices that do not have chef agent can still be configured with chef's device support over ssh/telnet. For such devices, chef uses push instead of pull approach.\n\n\n\n\nAudit and Compliance\n\n\nWith ability to define the state of the  infrastructure components as a code and then  converge, one could easily codify the infrastructure policies and have them enforced. chefs ability to test, log changes, and reporting mechanisms  help keeping a trail of the state of the systems and its components over time and track who made changes, when, if there are any nodes which have fallen out of policy etc.\n\n\nWhen to Use chef ?\n\n\nYou should consider using chef for the following purposes,\n\n\n\n\nConfiguration Management\n + Change Management: You have many nodes to deploy with changes happening often. You need to update the nodes and applications running on those often.\n\n\nCompliance and Audit\n: When your organization has to comply to policies and you need an ability to convert those policies into a code which would auto correct and bring the nodes into the policy in case of configuration drifts. You also need to audit the systems regularly and prepare reports to find out which nodes have drifted away from the policy etc. as well as mitigate such issues.\n\n\nSoftware Delivery\n : If you are in business of building software and delivering as ova images or similar, chef is better approach to deliver the product and push updates to it.\n\n\n\n\nWho is it for?\n\n\n\n\nSystems Administrators/Engineers who are managing systems at scale and  need to install, configure, patch, monitor and maintain systems and prepared reports for.\n\n\nApplication Operations Engineers  who are responsible for installing, configuring, integrating, monitoring, maintaining application infrastructures.\n\n\nBuild and release engineers who are in charge of setting up environments for CI/CD cycles, as well as deploy/release applications to production environments.\n\n\nNetwork Engineers who configure and maintain networking devices such as CISCO Routers and Switches at scale.\n\n\nStorage Administrators who configure and maintain storage devices.\n\n\nDevelopers who are building application delivery to their customers. Also as users of the develops tools, developers may need to change application properties for  the environments that they create/use.  \n\n\n\n\nWhat chef is not?\n\n\n\n\n\n\nGraphical Management Tool (e.g. SCCM):\n  If you are looking for a tool which would allow you to manage everything through a graphical interface without writing any code or without ever having to use an editor, well chef is not the tool for you.  I have come across many engineers, who say \"well, the capabilities of chef sounds great, but can I do all of this using a GUI where I can just click click and get things done.... ? \" Well, its infrastructure as a code is what we are talking about. Even though enterprise chef chef offers a nice GUI, its mostly for reporting and classifications. Since I started using chef and similar tools, I have been using text editors more often.\n\n\n\n\n\n\nAutomated Testing Tool ( e.g. selenium ):\n  Its not a silver bullet. Its not one solutions to all. I meet a lot of QA folks who have heard that chef would automate everything and you could use it for testing too.  Well, there is always a special purpose tool for each task and the application testing is not chef's ball game.  Sure chef could help in testing by letting you automate the process of building and configuring a fresh environment to run your tests inside, and give you ability to do it repeatedly. It also gives you a way to test infrastrcuture code. However, its not a test automation tool.\n\n\n\n\n\n\nPure Application Deployment and Orchestration Tool:\n  Even though chef has been talking about application orchestration, if you are looking for a tool purely for application deployments, rolling updates, canary releases, orchestrated deployments over multiple hosts, you have tools which do it better. A few  tools I could suggest you for application deployment and orchestration are Asible, Capistrano, Code Deploy  which are push based, and work better in such scenarios.\n\n\n\n\n\n\nAgent less Management System:\n  Except for a sub set of network devices, chef mandates running agents on each node being managed. In fact its designed to be heavy on the agent side which is responsible to initiate communication with the master, pull policies,  enforce and report back.  If you need a agent less management system, chef is not the one. Again, I would suggest using Ansible in such cases, which works over ssh and is agent less.\n\n\n\n\n\n\nSoftware Configuration Management(SCM) Tool\n  SCM is a part of the larger Configuration Management and typically refers to the practice of revision/version control. chef is not the tool which does the version control, however it can be used to replicate and manage software configurations across a cluster of nodes.\n\n\n\n\n\n\nA one stop  Devops solutions\n\n\n\n\n\n\nchef Use Cases/ Customer Stories\n\n\n\n\n\n\nChef vs Puppet\n\n\nchef vs Ansible\n\n\nchef vs Docker", 
            "title": "Introduction to Chef"
        }, 
        {
            "location": "/01_introduction/#how-i-got-started-with-puppet-chef-and-devops", 
            "text": "As Georg Buchner said:   We are only puppets, our strings\nare being pulled by unknown forces.   My journey with Devops began with Puppet ( a tool similar to chef, in fact Chef has  from this) back in 2008, when as I was part of the Ops Team managing web scale infrastructure for a SaaS company. Our team consisted of ops engineers in  India and US working out of  their respective timezones, keeping lights on 24x7.  As part of day to day operations, all of us would  make ad hoc changes to the servers, and not always communicate back with the team on the other side of the globe. We did not have daily sync up meetings either. As a result of this ad hoc, inconsistent setup, regularly, issues would pop up with the product, in pre production/integration as well as in production environments. Being in charge of triaging, my team would  spend a lot of time flipping through logs, doing root cause analysis and  figuring out whether its a problem due to inconsistent configurations or a actual code related issue. Tired of this fire fighting, we started looking for solutions to help us efficiently manage this environment. And thats when we came across Puppet, which was popular, was already picked by likes of google, and had an active community around it. We started using it to setup the infrastructure as well as manage changes through a centralized console.  Results were immediate, and tangible. After implementing puppet based configuration management system,    We now had a centralized tool which streamlined our process of managing configurations. This resulted in minimal ad hoc changes and  consistency  across the environments.    Visibility  was another important outcome. Since we started writing infrastructure as a Code, everyone including the developers had  visibility  into the way infrastructure was configured. All one had to do was look at the svn/git repository, the last commits to know what changes were made, my whom and when. What more, developers could even tweak the application properties in their own integration environments.    Error rates , specially related to configurations dropped  significantly, giving us more time back in our day, to focus on scale and other important issues.    That was the beginning of my journey with devops automation tools. Even though Puppet was the first kid on the block, Chef, which was released in 2009 has evolved to be a very mature, powerful and flexible automation tool, with a great community built around it.  Before we start looking into what makes puppet a excellent choice for a automation tool, lets first understand what configuration management is about.", 
            "title": "How I got started with Puppet, Chef  and Devops ?"
        }, 
        {
            "location": "/01_introduction/#infrastructure-life-events-and-chef", 
            "text": "If you are the one  who is in the business of managing  more than a handful of systems, you should be familiar with the term \"Configuration Management\" (not to confuse with traditional Software Configuration Management or SCM). Be it physical servers, virtual machines or cloud based setup, infrastructure typically goes through the  following life events,    Provisioning  Provision servers - physical, virtual or cloud. This is where the servers are brought into being.   Install Operating System either using manual/automated install process or using an image/template.    Configuration Management   Base Systems Configurations:  Prepare the systems with the base configurations such as users,  packages, security configurations, network setup etc.  Tech Stack: install and configure services such as apache, tomcat, middle wares, setup cron jobs, install and configure databases etc.   Application: Deploy the application code on top of the tech stack configured. This is where the code written by your team gets deployed with relevant configurations.    Change Management \n  Configurations made during the initial setup do not remain  do not last for a life time. Infrastructure is in the constant state of flux  and evolves over time. Change management involves,   Updating configurations parameters across a class of servers eg. update port that web server is running on.  Deploying new versions of the application code, push security patches etc, install additional services.   Chef serves as a excellent tool for Configuration Management as well as Change Management. And along with tools such as AWS Opsworks, Cloud Plugins, Vagrant, Terraform it could also  automate provisioning of servers too. However chef as a tool by itself does have an ability to provision and comes in to play once the Operating System is installed and chef agent is setup.  If you are looking for a tool which could also provision servers, and do it effectively, you should  consider Ansible.", 
            "title": "Infrastructure Life Events and Chef"
        }, 
        {
            "location": "/01_introduction/#evolution-of-configuration-management", 
            "text": "The need for managing configurations and ongoing  changes had been a challenge which has seen various approaches. Lets have a look at the evolution of configuration management,", 
            "title": "Evolution of Configuration Management"
        }, 
        {
            "location": "/01_introduction/#manual", 
            "text": "As systems engineers, we almost always begin configuring systems by hand, in a ad hoc manner. This approach is the easiest, and useful when you have only a handful of systems to manage, simple configurations, and where you do not have repeatable tasks or updates. However, as you start growing, this crude approach quickly gets out of control. It also involves manual processes, which mandates a operator to be present, and is prone to errors or omissions.", 
            "title": "Manual"
        }, 
        {
            "location": "/01_introduction/#scripts", 
            "text": "Scripts allow one to take a sequence of commands to run and put it in a procedural program. Whenever there is need to repeat the process,  scripts come in very handy. Some of the popular scripting languages amongst the systems personnel include shell/bash, perl, python, ruby or powershell.  Scripts are almost always the first approach towards automating manual tasks. However, scripts are not scalable or flexible enough to manage a sophisticated infrastructure spanning across multitude of environments or the ones involving multiple different operating systems etc.", 
            "title": "Scripts"
        }, 
        {
            "location": "/01_introduction/#configuration-management-and-software-configuration-management", 
            "text": "Software Configuration Management is referred to often with context of\nRevision Control which is about tracking changes to the application code.\nThis is just one part of a larger field of Configuration Management.", 
            "title": "Configuration Management and  Software Configuration Management"
        }, 
        {
            "location": "/01_introduction/#golden-images-templates", 
            "text": "Golden images, or templates, or simply os images, are probably the quickest way to deploy servers complete with configurations, specially in virtual or cloud environments. Images are nothing but pre baked templates with operations system files, applications, and configurations. Take any cloud provider, and one of the first components to choose while you provision a server is the images. A lot of organizations these days package their products in the form of images such as ova, vmdk or even vagrant's box format. However images have one major problem i.e. change management. Every time there is an update, even a single line change,  one needs to build a new image. Not only this complete system image needs to be distributed but also existing systems need to be replaced with the new image. Imagine doing that in a dynamic environment involving frequent updates across  hundreds of servers. That could get too cumbersome. And thats where the need to come up with a new approach.", 
            "title": "Golden Images/ Templates"
        }, 
        {
            "location": "/01_introduction/#infrastructure-as-a-code", 
            "text": "\"Infrastructure as a Code\" or \"Programmable Infrastructure\" is where today's generation tools such as Puppet, Chef, Ansible, Salt fit in. These tools essentially allow one to write the state of the infrastructure using a higher level descriptive  language and store it as a code. Since this is a code, one could bring in the best practices that developers have been following for years e.g. using revision control systems, use of sophisticated editors, test driven development, peer programming etc. You could  even build the complete infrastructure from scratch in case of a disaster, as long as you have the code repository, compute resources and data backups in place. Since this code is written in a simple declarative syntax, it is self documenting and offers visibility to all stakeholders into the way infrastructure is built and configured.     Approach  Advantages  Disadvantages           Manual  \\pbox{5cm}{simple}  \\pbox{5cm}{ad hoc, error prone, inconsistent, not repeatable}         Scripts  \\pbox{5cm}{repeatable, automated}  \\pbox{5cm}{procedural, not scalable, inflexible}         Images  \\pbox{5cm}{repeatable, automated}  \\pbox{5cm}{size, change management is not easy}         Infrastructure as a Code  \\pbox{5cm}{repeatable, flexible, scalable, automated, consistent}  \\pbox{5cm}{agent based, learning curve}", 
            "title": "Infrastructure as a Code"
        }, 
        {
            "location": "/01_introduction/#why-to-use-chef", 
            "text": "Now that we have started discussion on   Infrastructure as a Code, specifically chef, lets discuss about the specific features of chef that make it a useful tool for configuration and change management.", 
            "title": "Why to use chef ?"
        }, 
        {
            "location": "/01_introduction/#declarative-vs-procedural-approach", 
            "text": "Scripts take a procedural approach towards automation. With scripts, we focus on the  how  part. e.g. how to install a package, how to create a user, how to modify it later, how to do it on a specific platform. And if you would want to add a support for another platform, you may have to add additional procedure and write a conditional to check for the platform and call the relevant code. This involves a lot of efforts.  On the other hand, chef takes a declarative approach towards automation. With chef, our focus changes from    how  part to  what . Instead of writing procedures, we start using a simple declarative syntax to define the desired state of infrastructure.  Let me explain this with an analogy.  Lets say we want to build a house. When we  set out to do so, we hire a contractor, who in turns has a team of construction workers who know how to build it brick by brick. They do all the hard work to bring our house into a reality. Thats the  how  part.  On the other hand, you have a Architect. Lets take a moment and think about what he or she does. An Architect creates a plan, a blue print, which is nothing but a description of how your house should look like. The architect envisions the end state of your house, thinks about  what  should it consists of, breaks it down into components,  and starts creating  specification for each. He would then stitch it together to create a blueprint of our house, and hands it to the contractor to go and build it. This is the how part.  Thats exactly what we would start doing with chef, only difference being, we write the specification for desired state of IT infrastructure.", 
            "title": "Declarative vs Procedural Approach"
        }, 
        {
            "location": "/01_introduction/#resource-abstraction-layer", 
            "text": "We just learnt about chef allowing us to write the desired state of the infrastructure using a descriptive language. Now  this concept is brought into a reality with the its Domain Specific Language(DSL) which consists of a Resource Abstraction Layer (RAL). Lets describe how this works,  TODO : Create an image for each step below.   chef looks at  infrastructure as a collection of entities to manage e.g. package, service, user, network interface etc.  It then takes the  procedures, the actual logic to manage these entities and  bundles it into something called as  Providers . Providers are platform specific. That way, each entity may have multiple providers e.g. managing user on linux vs osx vs windows.  On top of these procedures, chef creates an abstraction layer. Instead of defining the procedures, it offers the users a simple declarative syntax to define the state of the entity and its properties, in the form of  Resources .  chef, then does the translation between Resources and Providers, and calls the procedure to put the entity in to the desired state just as described by the user.   This behavior allows the users of the chef to create policies stating what which entities should be present or absent, with what properties.", 
            "title": "Resource Abstraction Layer"
        }, 
        {
            "location": "/01_introduction/#convergence-and-idempotence", 
            "text": "chef reads the resources, calls the relevant providers for the platform it runs on, and ensures the desired state of the resource is achieved. While it does so, it may need to make changes to the system. But what if the resource has already achieved the desired state and needs no further updates?  chef has the  built in intelligence to know what is the current state of the resource is. Instead of making changes blindly, it first compares the current state of the resource with the desired state, and the makes a decision whether it requires any changes, and if yes, what changes to make.  This process is called as convergence.  TODO : Draw diagrams, maybe just a flowchart  e.g.  Lets assume we have written a resource to create  a user  with a password.  user 'xyz' do\n  uid   '501'\n  gid   '501'\n  home  '/home/xyz'\n  password  '$1$foYKL0zO$elXbUOb/JjHqS4aI8O25i.'\nend    First time chef applies this resource on the system, the user may not exist. chef detects the current state, compares it with the desired state which mentions it should exist, and finds the configuration drift. It then creates the user with the password to bring the current state to desired state.    Lets assume we run chef again to apply the same resource. This time too it will compare the desired state with current state. Since the user is already present with the password provided, it deems no changes necessary. Instead of attempting to create the user again, it will skip the resource and move on to the next one.    Lets assume we updated the password information for the user in our code description of the resource, and excute chef. This time, while comparing the current state with desired state, it detects that the user is present, but the password is updated. It does not attempt to create a user, but only changes one property i.e. password.    Idempotence is a useful property to  ensures that chef maintains the state of the infrastructure such that its always  in the policy. This also makes change management easier as one could keep running chef as a service which invokes itself at regular intervals, pulls the changes, and apply only what is changed.", 
            "title": "Convergence and Idempotence"
        }, 
        {
            "location": "/01_introduction/#centralized-configuration-management-system", 
            "text": "A typical installation of chef involves  a chef Master, which is a centralized management console and Agents runnings on every node managed.  Any changes to nodes have to go through the chef Master. This streamlines the process of pushing updated.  Instead of iterating over a list of hosts using a for loop or other such methods, or logging into each system to make changes, all you need to do is push updates to chef Server, from where those are automatically propogated to the nodes.  TODO", 
            "title": "Centralized Configuration Management System"
        }, 
        {
            "location": "/01_introduction/#pull-approach", 
            "text": "While chef offers a centralized management approach, it works unlike most client server schemes. Instead of pushing updates to the nodes from master, its the duty of chef agent to go the master,  pull changes, and apply. Pull method offers more flexibility and scalability for the following reasons,    Each node could decide how frequently or infrequently it should update. Some systems need frequent updates, where as others need not be updated for weeks. This could be controlled at  per client level.    No need to manage inventory and connection details on the master. Nodes could come and go, and could be configured based on dynamic rules to classify them based on certain property e.g. host names, environments, or even hardware addresses.    With push based approach, master must have a ability reach out and connect to each node managed in order to configure it. A lot of times you may have a master on a cloud or in a separate data center than nodes being managed, which could be behind a firewall or NAT device in a private network. In case of pull method, as long as the master is available on a well known address, and is reachable from the nodes, configurations can be pulled and applied.", 
            "title": "Pull Approach"
        }, 
        {
            "location": "/01_introduction/#code-vs-data", 
            "text": "A lot of applications that we configure on our servers are generic eg. apache, tomcat, mysql, mongo. These applications have a install base of hundreds of thousands of servers, used by organizations across the globe. Ever wondered how these become specific to your environment ? Even though you use the same apache web server used by many others, its how you configure it makes the difference. Even in single organization, you may have a apache server which behaves differently in different environment based on the configuration profile created. The process of setting up an application involves,   Installing the generic application either from a source, package or a repository.  Adding data. This where you set configuration parameters  e.g. port, user, max connections, webroot for apache.  Start, enable the service.   chef allows separation of  code and data.   Using chef's DSL, we write infrastructure code to install packages start services etc. Code is generic.  chef's attributes templates, along with dat bags and attribute precedence rules provide a way to create different configuration profiles specific to different nodes, environments, platforms etc.", 
            "title": "Code vs Data"
        }, 
        {
            "location": "/01_introduction/#shared-library-of-infrastructure-code", 
            "text": "With chef's ability to separate code and configuration data, the declarative code that you write in the form of modules with  chef becomes generic enough to be shared and be reused. And since this code is in the version control, hosted services such as github offer the perfect means to publish this code. As you start writing code with chef, you would discover about chef forge, a library of community written modules. At the time of writing, there are more than 4000 modules available on chef forge. Similar to a lot of open source code, you need not re invent the wheel. For most open source applications, you would find very sophisticated modules which you could use without even single line change. Download the modules, install it on your own chef master, add configuration profile, and off you go.", 
            "title": "Shared Library of Infrastructure Code"
        }, 
        {
            "location": "/01_introduction/#cloud-integrations", 
            "text": "With emergence of cloud, computing is moving towards the utility model. More and more organizations have already migrated or contemplating to migrate a partial or whole of their computing setup to cloud. And with that happening, which ever automation tool that you would consider, needs to have a close integration with the cloud platform that you plan to use. Provisioning of infrastructure components before chef comes in and starts configuring  There are two ways chef provides a way for this,    Through library of custom resources/libraries  which allow one to write provisioning of cloud components in the form of resources.    Cloud specific tools e.g. Cloudformation on AWS or Heat on Openstack are some of the tools which help provision components which are specific to that cloud and then call chef to do the configurations.    Third party tools such as Vagrant, Terraform have in turn ability to talk to multiple cloud providers. These tools typically provision servers on the cloud and then hand it off to chef for configurations.", 
            "title": "Cloud Integrations"
        }, 
        {
            "location": "/01_introduction/#iterative-approach-to-automation", 
            "text": "However convinced you are with chef, scrapping  your existing automation tool  overnight for a shiny new tool may have  unknown risks attached. More over, it may could  be challenging  to get a buy in from your management to invest in time, money and resources to implement a new solution without showing them the value.  With chef, you could take a iterative approach towards automation. You could start with a single application, or even a single entity such as a system user to manage. Once you see the value, show it to all stake holders, get a buy in and move to the next application, one at a time.", 
            "title": "Iterative Approach to Automation"
        }, 
        {
            "location": "/01_introduction/#device-support", 
            "text": "Managing configurations on systems running common operating systems such as windows, linux, os x, where chef agent application  can be installed is easy.  Its a completely different beast when it comes to   managing configurations on  devices running their own specialized version of operating systems/firmwares. Examples are configuring CISCO's network switches routers, EMC's storage array.  Along with programmable infrastructures, new concepts such as Software Defined Networking(SDN) and Software Defined Storage(SDS) are taking root and changing the way devices are being managed. chef supports managing devices in two ways,   Devices that are based on linux and have chef agent ported to run on those can be configured the same way as other generic systems.  Sub set of devices that do not have chef agent can still be configured with chef's device support over ssh/telnet. For such devices, chef uses push instead of pull approach.", 
            "title": "Device Support"
        }, 
        {
            "location": "/01_introduction/#audit-and-compliance", 
            "text": "With ability to define the state of the  infrastructure components as a code and then  converge, one could easily codify the infrastructure policies and have them enforced. chefs ability to test, log changes, and reporting mechanisms  help keeping a trail of the state of the systems and its components over time and track who made changes, when, if there are any nodes which have fallen out of policy etc.", 
            "title": "Audit and Compliance"
        }, 
        {
            "location": "/01_introduction/#when-to-use-chef", 
            "text": "You should consider using chef for the following purposes,   Configuration Management  + Change Management: You have many nodes to deploy with changes happening often. You need to update the nodes and applications running on those often.  Compliance and Audit : When your organization has to comply to policies and you need an ability to convert those policies into a code which would auto correct and bring the nodes into the policy in case of configuration drifts. You also need to audit the systems regularly and prepare reports to find out which nodes have drifted away from the policy etc. as well as mitigate such issues.  Software Delivery  : If you are in business of building software and delivering as ova images or similar, chef is better approach to deliver the product and push updates to it.", 
            "title": "When to Use chef ?"
        }, 
        {
            "location": "/01_introduction/#who-is-it-for", 
            "text": "Systems Administrators/Engineers who are managing systems at scale and  need to install, configure, patch, monitor and maintain systems and prepared reports for.  Application Operations Engineers  who are responsible for installing, configuring, integrating, monitoring, maintaining application infrastructures.  Build and release engineers who are in charge of setting up environments for CI/CD cycles, as well as deploy/release applications to production environments.  Network Engineers who configure and maintain networking devices such as CISCO Routers and Switches at scale.  Storage Administrators who configure and maintain storage devices.  Developers who are building application delivery to their customers. Also as users of the develops tools, developers may need to change application properties for  the environments that they create/use.", 
            "title": "Who is it for?"
        }, 
        {
            "location": "/01_introduction/#what-chef-is-not", 
            "text": "Graphical Management Tool (e.g. SCCM):\n  If you are looking for a tool which would allow you to manage everything through a graphical interface without writing any code or without ever having to use an editor, well chef is not the tool for you.  I have come across many engineers, who say \"well, the capabilities of chef sounds great, but can I do all of this using a GUI where I can just click click and get things done.... ? \" Well, its infrastructure as a code is what we are talking about. Even though enterprise chef chef offers a nice GUI, its mostly for reporting and classifications. Since I started using chef and similar tools, I have been using text editors more often.    Automated Testing Tool ( e.g. selenium ):\n  Its not a silver bullet. Its not one solutions to all. I meet a lot of QA folks who have heard that chef would automate everything and you could use it for testing too.  Well, there is always a special purpose tool for each task and the application testing is not chef's ball game.  Sure chef could help in testing by letting you automate the process of building and configuring a fresh environment to run your tests inside, and give you ability to do it repeatedly. It also gives you a way to test infrastrcuture code. However, its not a test automation tool.    Pure Application Deployment and Orchestration Tool:\n  Even though chef has been talking about application orchestration, if you are looking for a tool purely for application deployments, rolling updates, canary releases, orchestrated deployments over multiple hosts, you have tools which do it better. A few  tools I could suggest you for application deployment and orchestration are Asible, Capistrano, Code Deploy  which are push based, and work better in such scenarios.    Agent less Management System:\n  Except for a sub set of network devices, chef mandates running agents on each node being managed. In fact its designed to be heavy on the agent side which is responsible to initiate communication with the master, pull policies,  enforce and report back.  If you need a agent less management system, chef is not the one. Again, I would suggest using Ansible in such cases, which works over ssh and is agent less.    Software Configuration Management(SCM) Tool\n  SCM is a part of the larger Configuration Management and typically refers to the practice of revision/version control. chef is not the tool which does the version control, however it can be used to replicate and manage software configurations across a cluster of nodes.    A one stop  Devops solutions    chef Use Cases/ Customer Stories", 
            "title": "What chef is not?"
        }, 
        {
            "location": "/01_introduction/#chef-vs-puppet", 
            "text": "", 
            "title": "Chef vs Puppet"
        }, 
        {
            "location": "/01_introduction/#chef-vs-ansible", 
            "text": "", 
            "title": "chef vs Ansible"
        }, 
        {
            "location": "/01_introduction/#chef-vs-docker", 
            "text": "", 
            "title": "chef vs Docker"
        }, 
        {
            "location": "/03_resources_and_recipies/", 
            "text": "Resources and Recipes\n\n\nResources\n\n\nA resource is a statement of configuration policy that describes the desired state of a node.\n\n\n\n\nBlock of code, declares the desired state of a node.\n\n\nResource type\u2014such as package, template, or service.\n\n\n\n\nWhere a resource represents a piece of the system and the steps that are needed to bring that piece of the system from its current state into the desired state.\n\n\nRecipes\n\n\n\n\nCollection of resources in a single file is called recipes.\n\n\nRecipes must be stored in a cookbook.\n\n\nOne recipe may be included in another recipe.\n\n\nMay use the results of a search query and read the contents of a data bag (including an encrypted data bag)\n\n\nRecipe must be added to a run-list before it can be used by the chef-client\n\n\nIs always executed in the same order as listed in a run-list\n\n\n\n\nWriting our First recipe\n\n\nLets start creating a recipe file named as \nbase.rb\n, with the following resource specification\n  - Creating \nuser\n - deploy\n  - Removing \nuser\n - dojo\n  - Installing \npackages\n - tree, git, ntp, wget, unzip\n  - Add content to motd \nfile\n\n  - Start \nntp\n service\n\n\nBefore Writing a recipe lets have a look of available resources \nhere\n[^chef_resources] to build of recipe.\n\n\n\n\nOur recipe start with creating a \nuser\n resources, for creating a user called \ndeploy\n\n\n\n\nuser 'deploy' do\n  action :create\nend\n\n\n\n\n\n\nThe above resource will create only user \ndeploy\n to add more information to user resources, \nclick here\n[^user_resources]\n\n\nLet us create password for our user \ndeploy\n, which need to be encrypted.\n\n\nIn terminal use this command and enter paswword twice to create a encrypted password \nopenssl passwd -l\n\n\n\n\nuser 'deploy' do\n  uid 5001\n  home '/home/deploy'\n  action :create\n  password '$1$Ze1eJK3R$j5I0NRP5WxbZAaeXcfYW7/'\nend\n\n\n\n\nSyntax Check\n\n\n\n\nTo check the syntax of ruby file we use \nruby -c \nfile_name.rb\n where \n-c\n is used to \"check syntax only\".\n\n\n\n\nruby -c base.rb\n\n\n\n\nExecute Recipe with Chef Client in Local Mode\n\n\n\n\nWe will be using \nChef-client\n command with \n--local-mode\n or \n-z\n to run in localhost(chef workstation).\n\n\n\n\nchef-client --local-mode --log_level info \nfile_name.rb\n\nor\nchef-client -z -l \nfile_name.rb\n\n\n\n\n\n\n\nIn the above we use \n--log_level info\n info or \n-l\n to get the detailed information on \nchef-client\n run.\n\n\n\n\nUsing Why (Dry) Run\n\n\n\n\nBefore applying recipe directly we will be using dry run mode to check what this recipe \nwould\n do\n\n\nTo use dry run and check what this recipe will do, we could use \n--why-run\n or \n-w\n with \nchef-client\n command.\n\n\n\n\nchef-client --local-mode --log_level info --why-run \nfile_name.rb\n\nor\nchef-client -z -l -w \nfile_name.rb\n\n\n\n\n\n\n\nBy running \nchef-client -z -l -w base.rb\n tells that \nuser deploy\n \nwould\n be created, and not really created, because of why run mode.\n\n\n\n\nRunning our first recipe\n\n\n\n\nAfter checking with dry run, we can apply our recipe to the local node.\n\n\n\n\nchef-client --local-mode --log_level info base.rb\nor\nchef-apply base.rb\n\n\n\n\nWhat it does?\n\n\n\n\nIt creates user \ndeploy\n with specified UID and home directory in local machine.\n\n\nRun \nid deploy\n to check the details of user deploy.\n\n\n\n\nIdempotence\n\n\nLets run chef-client again to reapply with same options\n\n\nchef-client -z -l base.rb\n\n\n\n\nWhat happened when we run again the chef-client command?\n\n\n\n\nIt checks for the presence of user \ndeploy\n and hence it \nSkipped\n executing \nuser\n resources.\n\n\nThis is how, \nidempotent\n of \nchef\n works.\n\n\n\n\nLAB Exercises\n\n\nWe created \nuser deploy\n now let us add the remaining resources to our \nbase.rb\n recipe.\n  - Removing \nuser\n - dojo\n  - Installing \npackages\n - tree, git, ntp, wget, unzip\n  - Add content to motd \nfile\n\n  - Start \nntp\n service\n\n\nCommon Functionality\n\n\nResources can have some common functionality like sharing properties, conditionals and relative actions.\n\n\nActions\n\n\naction :nothing\n\n\nThe above common functionality can be used with any resource block to do nothing until notified by another resource to take action.\n\n\nNotifications\n\n\nThis property is used to listens to other resources in the resource collection and then takes actions based on the notification type (\nnotifies\n or \nsubscribes\n).\n\n\nThe syntax for notifies is:\n\n\nnotifies :action, 'resource[name]', :timer\n\n\n\n\nTimers\n\n\nA timer specifies the point during the chef-client run at which a notification is run.\n\n\n:before\n\n\n\n\nSpecifies that the action on a notified resource should be run before processing the resource block in which the notification is located.\n\n\n:delayed\n\n\n\n\nDefault. Specifies that a notification should be queued up, and then executed at the very end of the chef-client run.\n\n\n:immediate, :immediately\n\n\n\n\nSpecifies that a notification should be run immediately, per resource notified.\n\n\nResource with Guards\n\n\n\n\nTo prevent the execute command from running again and again and providing idempotent to it, we use \ngaurds\n one of the common functionality along with the resource.\n\n\n\n\nGaurds\n\n\nThe following properties can be used to define a guard that is evaluated during the execution phase of the chef-client run:\n\n\n\n\n\n\nnot_if - Prevent a resource from executing when the condition returns true.\n\n\n\n\n\n\nonly_if - Allow a resource to execute only if the condition returns true.\n\n\n\n\n\n\nClick here\n[^deploy_facebooc] for \ndeploy_facebooc.rb\n recipe for common functionality, as shown below\n\n\npackage ['libsqlite3-dev', 'sqlite3']\n\nexecute 'download_facebooc_from_source' do\n  command 'wget https://github.com/jserv/facebooc/archive/master.zip'\n  cwd '/opt'\n  user 'root'\n  creates '/opt/master.zip'\n  notifies :run, 'execute[extract_facebook_app]', :immediately\nend\n\n\nexecute 'extract_facebook_app' do\n  command 'unzip master.zip  \n touch /opt/.facebooc_compile'\n  cwd '/opt'\n  user 'root'\n  action :nothing\nend\n\n\nexecute 'compile_facebooc' do\n  command 'make all \n rm /opt/.facebooc_compile'\n  cwd '/opt/facebooc-master'\n  user 'root'\n  only_if 'test -f /opt/.facebooc_compile'\n  action :run\nend\n\n\nexecute 'run_facebooc' do\n  command 'bin/facebooc 16000 \n'\n  cwd '/opt/facebooc-master'\n  user 'root'\n  not_if 'netstat -an | grep 16000 | grep -i listen'\n  action :run\nend\n\n\n\n\n[^chef_resources]: Chef Resources - https://docs.chef.io/resource.html\n[^user_resources]: User Resources - https://docs.chef.io/resource_user.html\n[^deploy_facebooc]: Deploy_Facebooc Recipie - https://gist.github.com/initcron/eff10a8e5bde59b356a485539579d634", 
            "title": "Resources and Recipes"
        }, 
        {
            "location": "/03_resources_and_recipies/#resources-and-recipes", 
            "text": "", 
            "title": "Resources and Recipes"
        }, 
        {
            "location": "/03_resources_and_recipies/#resources", 
            "text": "A resource is a statement of configuration policy that describes the desired state of a node.   Block of code, declares the desired state of a node.  Resource type\u2014such as package, template, or service.   Where a resource represents a piece of the system and the steps that are needed to bring that piece of the system from its current state into the desired state.", 
            "title": "Resources"
        }, 
        {
            "location": "/03_resources_and_recipies/#recipes", 
            "text": "Collection of resources in a single file is called recipes.  Recipes must be stored in a cookbook.  One recipe may be included in another recipe.  May use the results of a search query and read the contents of a data bag (including an encrypted data bag)  Recipe must be added to a run-list before it can be used by the chef-client  Is always executed in the same order as listed in a run-list", 
            "title": "Recipes"
        }, 
        {
            "location": "/03_resources_and_recipies/#writing-our-first-recipe", 
            "text": "Lets start creating a recipe file named as  base.rb , with the following resource specification\n  - Creating  user  - deploy\n  - Removing  user  - dojo\n  - Installing  packages  - tree, git, ntp, wget, unzip\n  - Add content to motd  file \n  - Start  ntp  service  Before Writing a recipe lets have a look of available resources  here [^chef_resources] to build of recipe.   Our recipe start with creating a  user  resources, for creating a user called  deploy   user 'deploy' do\n  action :create\nend   The above resource will create only user  deploy  to add more information to user resources,  click here [^user_resources]  Let us create password for our user  deploy , which need to be encrypted.  In terminal use this command and enter paswword twice to create a encrypted password  openssl passwd -l   user 'deploy' do\n  uid 5001\n  home '/home/deploy'\n  action :create\n  password '$1$Ze1eJK3R$j5I0NRP5WxbZAaeXcfYW7/'\nend", 
            "title": "Writing our First recipe"
        }, 
        {
            "location": "/03_resources_and_recipies/#syntax-check", 
            "text": "To check the syntax of ruby file we use  ruby -c  file_name.rb  where  -c  is used to \"check syntax only\".   ruby -c base.rb", 
            "title": "Syntax Check"
        }, 
        {
            "location": "/03_resources_and_recipies/#execute-recipe-with-chef-client-in-local-mode", 
            "text": "We will be using  Chef-client  command with  --local-mode  or  -z  to run in localhost(chef workstation).   chef-client --local-mode --log_level info  file_name.rb \nor\nchef-client -z -l  file_name.rb    In the above we use  --log_level info  info or  -l  to get the detailed information on  chef-client  run.", 
            "title": "Execute Recipe with Chef Client in Local Mode"
        }, 
        {
            "location": "/03_resources_and_recipies/#using-why-dry-run", 
            "text": "Before applying recipe directly we will be using dry run mode to check what this recipe  would  do  To use dry run and check what this recipe will do, we could use  --why-run  or  -w  with  chef-client  command.   chef-client --local-mode --log_level info --why-run  file_name.rb \nor\nchef-client -z -l -w  file_name.rb    By running  chef-client -z -l -w base.rb  tells that  user deploy   would  be created, and not really created, because of why run mode.", 
            "title": "Using Why (Dry) Run"
        }, 
        {
            "location": "/03_resources_and_recipies/#running-our-first-recipe", 
            "text": "After checking with dry run, we can apply our recipe to the local node.   chef-client --local-mode --log_level info base.rb\nor\nchef-apply base.rb  What it does?   It creates user  deploy  with specified UID and home directory in local machine.  Run  id deploy  to check the details of user deploy.", 
            "title": "Running our first recipe"
        }, 
        {
            "location": "/03_resources_and_recipies/#idempotence", 
            "text": "Lets run chef-client again to reapply with same options  chef-client -z -l base.rb  What happened when we run again the chef-client command?   It checks for the presence of user  deploy  and hence it  Skipped  executing  user  resources.  This is how,  idempotent  of  chef  works.", 
            "title": "Idempotence"
        }, 
        {
            "location": "/03_resources_and_recipies/#lab-exercises", 
            "text": "We created  user deploy  now let us add the remaining resources to our  base.rb  recipe.\n  - Removing  user  - dojo\n  - Installing  packages  - tree, git, ntp, wget, unzip\n  - Add content to motd  file \n  - Start  ntp  service", 
            "title": "LAB Exercises"
        }, 
        {
            "location": "/03_resources_and_recipies/#common-functionality", 
            "text": "Resources can have some common functionality like sharing properties, conditionals and relative actions.", 
            "title": "Common Functionality"
        }, 
        {
            "location": "/03_resources_and_recipies/#actions", 
            "text": "action :nothing  The above common functionality can be used with any resource block to do nothing until notified by another resource to take action.", 
            "title": "Actions"
        }, 
        {
            "location": "/03_resources_and_recipies/#notifications", 
            "text": "This property is used to listens to other resources in the resource collection and then takes actions based on the notification type ( notifies  or  subscribes ).  The syntax for notifies is:  notifies :action, 'resource[name]', :timer", 
            "title": "Notifications"
        }, 
        {
            "location": "/03_resources_and_recipies/#timers", 
            "text": "A timer specifies the point during the chef-client run at which a notification is run.  :before  Specifies that the action on a notified resource should be run before processing the resource block in which the notification is located.  :delayed  Default. Specifies that a notification should be queued up, and then executed at the very end of the chef-client run.  :immediate, :immediately  Specifies that a notification should be run immediately, per resource notified.", 
            "title": "Timers"
        }, 
        {
            "location": "/03_resources_and_recipies/#resource-with-guards", 
            "text": "To prevent the execute command from running again and again and providing idempotent to it, we use  gaurds  one of the common functionality along with the resource.   Gaurds  The following properties can be used to define a guard that is evaluated during the execution phase of the chef-client run:    not_if - Prevent a resource from executing when the condition returns true.    only_if - Allow a resource to execute only if the condition returns true.    Click here [^deploy_facebooc] for  deploy_facebooc.rb  recipe for common functionality, as shown below  package ['libsqlite3-dev', 'sqlite3']\n\nexecute 'download_facebooc_from_source' do\n  command 'wget https://github.com/jserv/facebooc/archive/master.zip'\n  cwd '/opt'\n  user 'root'\n  creates '/opt/master.zip'\n  notifies :run, 'execute[extract_facebook_app]', :immediately\nend\n\n\nexecute 'extract_facebook_app' do\n  command 'unzip master.zip    touch /opt/.facebooc_compile'\n  cwd '/opt'\n  user 'root'\n  action :nothing\nend\n\n\nexecute 'compile_facebooc' do\n  command 'make all   rm /opt/.facebooc_compile'\n  cwd '/opt/facebooc-master'\n  user 'root'\n  only_if 'test -f /opt/.facebooc_compile'\n  action :run\nend\n\n\nexecute 'run_facebooc' do\n  command 'bin/facebooc 16000  '\n  cwd '/opt/facebooc-master'\n  user 'root'\n  not_if 'netstat -an | grep 16000 | grep -i listen'\n  action :run\nend  [^chef_resources]: Chef Resources - https://docs.chef.io/resource.html\n[^user_resources]: User Resources - https://docs.chef.io/resource_user.html\n[^deploy_facebooc]: Deploy_Facebooc Recipie - https://gist.github.com/initcron/eff10a8e5bde59b356a485539579d634", 
            "title": "Resource with Guards"
        }, 
        {
            "location": "/04_cookbooks/", 
            "text": "Cookbook and Run_list\n\n\nIn the previous chapter we gone through resources and recipes, now let us go through Cookbook and Run_list in this chapter.\n\n\nWhat is Cookbook?\n\n\n\n\nCookbook contains configuration and policy which are created using Ruby as its reference language.\n\n\nCookbook is created with desired scenario in mind and contains required components to support the final scenario of a system.\n\n\nCookbook contains collection of various components as follows,\n\n\n\n\n\n\n\n\n\n\nComponents\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRecipes\n\n\n\\pbox{12cm}{Collection of resources in a single file is called recipes. Recipes are stored in a cookbook. Recipe must be added to a run-list before it can be used by the chef-client. Is always executed in the same order as listed in a run-list.}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAttributes\n\n\n\\pbox{12cm}{Attributes are used to override the default settings of the node.For each cookbook, attributes in the \ndefault.rb\n file are loaded first, and then additional attribute files (if present) are loaded in lexical sort order.}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFiles\n\n\n\\pbox{12cm}{Distributing any type of files to nodes, these are static files}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTemplates\n\n\n\\pbox{12cm}{A template is a file written in markup language that uses Ruby statements to solve complex configuration scenarios, and to update dynamic values.}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCookbook Versions\n\n\n\\pbox{12cm}{A cookbook version is used to maintain a various version of same file with different functionality. A version may exist for many reasons, such as ensuring the correct use of a third-party component, updating a bug fix, or adding an improvement.}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCommunity Cookbooks\n\n\nChef Maintained Cookbooks\n\n\nChef maintains a collection of cookbooks that are widely used by the community.\n\n\nCommunity Cookbooks\n\n\nThe community has authored thousands of cookbooks, ranging from niche cookbooks that are used by only a few organizations to cookbooks that are some of the most popular and are used by nearly everyone.\n\n\nChef Generate\n\n\n\n\nchef generate\n is a part of chef-dk and this command is used to generate a set of file system. Which can be used as a template.\n\n\nTo know more about \nchef generate\n you can check with the man page,\n\n\n\n\nchef generate\nUsage: chef generate GENERATOR [options]\n\nAvailable generators:\napp             Generate an application repo\ncookbook        Generate a single cookbook\nrecipe          Generate a new recipe\nattribute       Generate an attributes file\ntemplate        Generate a file template\nfile            Generate a cookbook file\nlwrp            Generate a lightweight resource/provider\nrepo            Generate a Chef code repository\npolicyfile      Generate a Policyfile for use with the install/push commands\ngenerator       Copy ChefDK's generator cookbook so you can customize\nbuild-cookbook  Generate a build cookbook for use with Delivery\n\n\n\n\nChef Generate -  App vs Cookbook\n\n\nThere are two methods to create code. Traditional approach has been to generate one repository per cookbook. The new approach is to generate one repository per Application, with cookbooks for each component e.g. a repo for web-app with cookbooks for tomcat, java, mysql, deployment.  \n\n\nThis method also uses a common test kitchen environment etc.\n\n\nTo find more information on comparison between App and Cookbook approach, refer to \nthis blog\n[^devopsguru_blog].\n\n\nExample of generating a app is\n\n\nchef generate app \napp_repo_name\n\n\n\n\n\nExample of generating a single cookbook  is\n\n\nchef generate cookbook \ncookbook_name\n\n\n\n\n\nGenerating App and Cookbooks to setup Webapp\n\n\nLet us generate a repo for our application named \"myapp\".\n\n\n\n\nStarts with creating a \nsysfoo\n repo for our application.\n\n\n\n\nchef generate app sysfoo\n\n\n\n\n\n\nLet us create a first cookbook for our tomcat application.\n\n\nInside app repo create a cookbooks for \ntomcat\n along with its prerequisite cookbook \njava\n\n\n\n\ncd sysfoo\n\nchef generate cookbook cookbooks/java\n\nchef generate cookbook cookbooks/tomcat\n\n\n\n\n\n\nApp repo and cookbooks are created.\n\n\n\n\nJava Cookbook\n\n\nRepo for java cookbook is generated now add resources to our cookbook.\n\n\n\n\ncreate a recipe to install \nepel-release\n and \njava-1.7.0-openjdk\n.\n\n\nIn \nmyapp/cookbooks/java/recipes/default.rb\n create a default recipe with the following content.\n\n\n\n\npackage 'epel-release' do\n  action :install\nend\n\npackage 'java-1.7.0-openjdk' do\n  action :install\nend\n\n\n\n\nLAB Exercise - Tomcat Cookbook\n\n\n\n\nCookbook for \ntomcat\n is already been generated .\n\n\nAdd one recipe \ninstall.rb\n to \ninstall\n \ntomcat\n and \ntomcat-webapps\n.\n\n\nAdd another recipe \nservice.rb\n to \nstart\n a \ntomcat service\n.\n\n\n\n\nCreating Local Environment to Test the Code\n\n\nWe have created cookbooks for Java and Tomcat and written reipes to install and configure tomcat. Before we uploade this code to the Chef Server and apply it at scale, its important that we test these recipes locally. Every subsequent change to the recipes need to be tested as well.\n\n\nWe may also need to test our code on multiple different platforms. Test kitchen offers us a way to create local test environments, apply the code and also execute automated tests to validate that our code works.\n\n\nIt could be used for\n\n Local development to create portable, use and throw test environments.\n\n Functional and Integration tests which could be triggered automatically as part of Continuous Integration environments.\n\n\nCreating Test Kitchen Configuration\n\n\nTest Kitchen comes with a configuration file .kitchen.yml . We have one file for each App and cookbooks. We would edit our top level .kitchen.yml file  available at sysfoo/.kitchen.yml\n\n\nMake sure it matches the following config\n\n\n---\ndriver:\n  name: docker\n\nprovisioner:\n  name: chef_zero\n  always_update_cookbooks: true\n\nverifier:\n  name: inspec\n\nplatforms:\n  - name: centos-6.8\n    driver_config:\n      image: codespaces/chef-node-centos-6\n      forward:\n        - 8080:8080\n\nsuites:\n  - name: default\n    run_list:\n      - recipe[sysfoo::default]\n    verifier:\n      inspec_tests:\n        - test/recipes\n    attributes:\n\n\n\n\n\nOnce created, check the current status of the environment by running ,\n\n\ncd /workspace/sysfoo/\nkitchen list\n\n\n\n\nTIP: Use yamllint.com to validate .kitchen.yaml if you get an error after running \nkitchen list\n\n\nCreate a Local Environment with Docker\n\n\nLocal environment for testing is created using docker, we will be uing \".kitchen.yml\" for creating a test environment.\n\n\n\n\nOnce the \n.kitchen.yml\n is updated we can create kitchen using \nkitchen create\n command, from the directory where \n.kitchen.yml\n file exists.\n\n\n\n\nkitchen create\n\n\n\n\n\n\nIt creates a docker container with \ncentos-6.8\n.\n\n\n\n\nkitchen list\n\n\n\n\n\n\nTo list the available instances and their information.\n\n\n\n\nAdding recipe to run_list\n\n\nOnce the test environment created we need to add recipes to the run_list for testing it.\n\n\n\n\nAdd both java and tomcat recipes to run_list in \n.kitchen.yml\n.\n\n\njava::install\n\n\ntomcat::install\n\n\ntomcat::service\n\n\n\n\nsuites:\n  - name: default\n    run_list:\n      - recipe[java::install]\n      - recipe[tomcat::install]\n      - recipe[tomcat::service]\n\n\n\n\nApply Chef Cookbooks\n\n\n\n\nOnce the instance is created it can be converged along with the \nrun_list\n specified in \n.kitchen.yml\n\n\n\n\nkitchen converge\n\n\n\n\n\n\nIt will \ninstall chef\n and then will apply run_list to the instances.\n\n\nTo verify, Login and check for java installation and version.\n\n\n\n\nkitchen login\n\n\n\n\n\n\nLogins to docker instance created by kitchen.\n\n\n\n\nwhich java\njava -version\nwhich tomcat\nservice tomcat status\n\n\n\n\nDestroying and Converging\n\n\n\n\nIf you wish to re create the environment from scratch, use kitchen destroy followed by kitchen converge\n\n\n\n\nkitchen destroy\nkitchen list\nkitchen converge\n\n\n\n\n\n\nRun converge command directly to \ncreate\n a instance and then \nconverge\n it and apply \nrun_list\n to it.\n\n\n\n\nVerify\n the converge by visiting \nhttp://ipaddress:8080\n for tomcat homepage.\n\n\n\n\nSimplifying Run_list\n\n\n\n\nLets make recipes simplified.\n\n\nFrom this recipie \n./myapp/cookbooks/tomcat/recipes/default.rb\n call all other recipes.\n\n\n\n\n#\n# Cookbook Name:: tomcat\n# Recipe:: default\n#\n# Copyright (c) 2017 The Authors, All Rights Reserved.\n\ninclude_recipe 'java'\n# we can also call the above recipe as\n# include_recipe 'java::default'\n\ninclude_recipe 'tomcat::install'\ninclude_recipe 'tomcat::service'\n\n\n\n\n\n\nNow change the run_list in \n./sysfoo/test/.kitchen.yml\n and add only \ntomcat::default\n\n\n\n\nsuites:\n  - name: default\n    run_list:\n      - recipe[tomcat]\n\n\n\n\n\n\nOnce added, now converge again.\n\n\nYou could get error because of java cookbook not found, but tomcat includes java in run_list.\n\n\nNow to add \ndepended java\n, add java dependency entry in the metadata file \n./myapp/cookbooks/tomcat/metadata.rb\n.\n\n\n\n\nname 'tomcat'\nmaintainer 'The Authors'\nmaintainer_email 'you@example.com'\nlicense 'all_rights'\ndescription 'Installs/Configures tomcat'\nlong_description 'Installs/Configures tomcat'\nversion '0.1.0'\n\ndepends 'java'\n\n\n\n\nManaging Files\n\n\n\n\nWe will need to manage configurations eg. tomcat.conf\n\n\nsince chef is a centralized configuration management system, we will keep the files centrally in cookbooks, which will then be copied to all managed nodes\n\n\n\n\nGenerating Files\n\n\n\n\nCreate \ntomcat.conf\n to manage the configuration of tomcat in all nodes.\n\n\nUse \nchef generate file\n in tomcat cookbook directory.\n\n\n\n\nchef generate file cookbooks/tomcat tomcat.conf\n\n\n\n\n\n\nNow \n./sysfoo/cookbooks/tomcat/files/default/tomcat.conf\n is generated using chef.\n\n\nUpdate \ntomcat.conf\n with the following content to manage tomcat.\n\n\n\n\nTOMCAT_CFG_LOADED=\n1\n\n\nJAVA_HOME=\n/usr/lib/jvm/jre\n\nJAVA_OPTS=\n-Xms64m -Xmx128m -XX:MaxPermSize=128M  \\\n-Djava.security.egd=file:/dev/./urandom\n\n\nCATALINA_BASE=\n/usr/share/tomcat\n\nCATALINA_HOME=\n/usr/share/tomcat\n\nJASPER_HOME=\n/usr/share/tomcat\n\nCATALINA_TMPDIR=\n/var/cache/tomcat/temp\n\n\nTOMCAT_USER=\ntomcat\n\n\nSECURITY_MANAGER=\nfalse\n\n\nSHUTDOWN_WAIT=\n30\n\n\nSHUTDOWN_VERBOSE=\nfalse\n\n\nCATALINA_PID=\n/var/run/tomcat.pid\n\n\n\n\n\n{todo}\nTIP: files/default\n\n\nRecipe to manage cookbook files\n\n\n\n\nNow to manage \ntomcat.conf\n create a recipe called \nconfig.rb\n in tomcat cookbook.\n\n\nUse \nchef generate recipe\n to generate recipe intomcat cookbook.\n\n\n\n\nchef generate recipe cookbooks/tomcat config\n\n\n\n\n\n\nNow \n./myapp/cookbooks/tomcat/recipes/config.rb\n is generated.\n\n\nAdd the following content into \nconfig.rb\n\n\n\n\ncookbook_file '/etc/tomcat/tomcat.conf' do\n  source 'tomcat.conf'\n  owner 'tomcat'\n  group 'tomcat'\n  mode  0644\n  action :create\nend\n\n\n\n\nRefreshing Services\n\n\n\n\nWe can use  \nnotifies\n with \ntimers\n to trigger another resources in a recipes.\n\n\nLet us add an entry to \nnotifies tomcat service\n in \nconfig.rb\n\n\n\n\ncookbook_file '/etc/tomcat/tomcat.conf' do\n  source 'tomcat.conf'\n  owner 'tomcat'\n  group 'tomcat'\n  mode  0644\n  action :create\n  notifies :restart, 'service[tomcat]', :delayed\nend\n\n\n\n\n\n\nIn the above \nservice tomcat\n will be restarted if there is any change in \ncookbook_file\n resource.\n\n\nonce \nconfig.rb\n recipe is created add an entry for run_list in \ndefault.rb\n of tomcat cookbook for applying it to nodes, as follows.\n\n\n\n\ninclude_recipe 'tomcat::config'\n\n\n\n\n\n\nNow \nkitchen converge\n and check logs to see \nservice tomcat\n is being \nrestarted\n for every change made in \ntomcat.conf\n file.\n\n\nNow verify by logging into docker instance using \nkitchen login\n.\n\n\n\n\n[^devopsguru_blog]: Devopsguru Blog - http://devopsguru.tumblr.com/post/147717124737/chef-generate-app-vs-chef-generate-cookbook-vs", 
            "title": "Cookbooks"
        }, 
        {
            "location": "/04_cookbooks/#cookbook-and-run_list", 
            "text": "In the previous chapter we gone through resources and recipes, now let us go through Cookbook and Run_list in this chapter.", 
            "title": "Cookbook and Run_list"
        }, 
        {
            "location": "/04_cookbooks/#what-is-cookbook", 
            "text": "Cookbook contains configuration and policy which are created using Ruby as its reference language.  Cookbook is created with desired scenario in mind and contains required components to support the final scenario of a system.  Cookbook contains collection of various components as follows,      Components  Description          Recipes  \\pbox{12cm}{Collection of resources in a single file is called recipes. Recipes are stored in a cookbook. Recipe must be added to a run-list before it can be used by the chef-client. Is always executed in the same order as listed in a run-list.}        Attributes  \\pbox{12cm}{Attributes are used to override the default settings of the node.For each cookbook, attributes in the  default.rb  file are loaded first, and then additional attribute files (if present) are loaded in lexical sort order.}        Files  \\pbox{12cm}{Distributing any type of files to nodes, these are static files}        Templates  \\pbox{12cm}{A template is a file written in markup language that uses Ruby statements to solve complex configuration scenarios, and to update dynamic values.}        Cookbook Versions  \\pbox{12cm}{A cookbook version is used to maintain a various version of same file with different functionality. A version may exist for many reasons, such as ensuring the correct use of a third-party component, updating a bug fix, or adding an improvement.}", 
            "title": "What is Cookbook?"
        }, 
        {
            "location": "/04_cookbooks/#community-cookbooks", 
            "text": "Chef Maintained Cookbooks  Chef maintains a collection of cookbooks that are widely used by the community.  Community Cookbooks  The community has authored thousands of cookbooks, ranging from niche cookbooks that are used by only a few organizations to cookbooks that are some of the most popular and are used by nearly everyone.", 
            "title": "Community Cookbooks"
        }, 
        {
            "location": "/04_cookbooks/#chef-generate", 
            "text": "chef generate  is a part of chef-dk and this command is used to generate a set of file system. Which can be used as a template.  To know more about  chef generate  you can check with the man page,   chef generate\nUsage: chef generate GENERATOR [options]\n\nAvailable generators:\napp             Generate an application repo\ncookbook        Generate a single cookbook\nrecipe          Generate a new recipe\nattribute       Generate an attributes file\ntemplate        Generate a file template\nfile            Generate a cookbook file\nlwrp            Generate a lightweight resource/provider\nrepo            Generate a Chef code repository\npolicyfile      Generate a Policyfile for use with the install/push commands\ngenerator       Copy ChefDK's generator cookbook so you can customize\nbuild-cookbook  Generate a build cookbook for use with Delivery", 
            "title": "Chef Generate"
        }, 
        {
            "location": "/04_cookbooks/#chef-generate-app-vs-cookbook", 
            "text": "There are two methods to create code. Traditional approach has been to generate one repository per cookbook. The new approach is to generate one repository per Application, with cookbooks for each component e.g. a repo for web-app with cookbooks for tomcat, java, mysql, deployment.    This method also uses a common test kitchen environment etc.  To find more information on comparison between App and Cookbook approach, refer to  this blog [^devopsguru_blog].  Example of generating a app is  chef generate app  app_repo_name   Example of generating a single cookbook  is  chef generate cookbook  cookbook_name", 
            "title": "Chef Generate -  App vs Cookbook"
        }, 
        {
            "location": "/04_cookbooks/#generating-app-and-cookbooks-to-setup-webapp", 
            "text": "Let us generate a repo for our application named \"myapp\".   Starts with creating a  sysfoo  repo for our application.   chef generate app sysfoo   Let us create a first cookbook for our tomcat application.  Inside app repo create a cookbooks for  tomcat  along with its prerequisite cookbook  java   cd sysfoo\n\nchef generate cookbook cookbooks/java\n\nchef generate cookbook cookbooks/tomcat   App repo and cookbooks are created.", 
            "title": "Generating App and Cookbooks to setup Webapp"
        }, 
        {
            "location": "/04_cookbooks/#java-cookbook", 
            "text": "Repo for java cookbook is generated now add resources to our cookbook.   create a recipe to install  epel-release  and  java-1.7.0-openjdk .  In  myapp/cookbooks/java/recipes/default.rb  create a default recipe with the following content.   package 'epel-release' do\n  action :install\nend\n\npackage 'java-1.7.0-openjdk' do\n  action :install\nend", 
            "title": "Java Cookbook"
        }, 
        {
            "location": "/04_cookbooks/#lab-exercise-tomcat-cookbook", 
            "text": "Cookbook for  tomcat  is already been generated .  Add one recipe  install.rb  to  install   tomcat  and  tomcat-webapps .  Add another recipe  service.rb  to  start  a  tomcat service .", 
            "title": "LAB Exercise - Tomcat Cookbook"
        }, 
        {
            "location": "/04_cookbooks/#creating-local-environment-to-test-the-code", 
            "text": "We have created cookbooks for Java and Tomcat and written reipes to install and configure tomcat. Before we uploade this code to the Chef Server and apply it at scale, its important that we test these recipes locally. Every subsequent change to the recipes need to be tested as well.  We may also need to test our code on multiple different platforms. Test kitchen offers us a way to create local test environments, apply the code and also execute automated tests to validate that our code works.  It could be used for  Local development to create portable, use and throw test environments.  Functional and Integration tests which could be triggered automatically as part of Continuous Integration environments.", 
            "title": "Creating Local Environment to Test the Code"
        }, 
        {
            "location": "/04_cookbooks/#creating-test-kitchen-configuration", 
            "text": "Test Kitchen comes with a configuration file .kitchen.yml . We have one file for each App and cookbooks. We would edit our top level .kitchen.yml file  available at sysfoo/.kitchen.yml  Make sure it matches the following config  ---\ndriver:\n  name: docker\n\nprovisioner:\n  name: chef_zero\n  always_update_cookbooks: true\n\nverifier:\n  name: inspec\n\nplatforms:\n  - name: centos-6.8\n    driver_config:\n      image: codespaces/chef-node-centos-6\n      forward:\n        - 8080:8080\n\nsuites:\n  - name: default\n    run_list:\n      - recipe[sysfoo::default]\n    verifier:\n      inspec_tests:\n        - test/recipes\n    attributes:  Once created, check the current status of the environment by running ,  cd /workspace/sysfoo/\nkitchen list  TIP: Use yamllint.com to validate .kitchen.yaml if you get an error after running  kitchen list", 
            "title": "Creating Test Kitchen Configuration"
        }, 
        {
            "location": "/04_cookbooks/#create-a-local-environment-with-docker", 
            "text": "Local environment for testing is created using docker, we will be uing \".kitchen.yml\" for creating a test environment.   Once the  .kitchen.yml  is updated we can create kitchen using  kitchen create  command, from the directory where  .kitchen.yml  file exists.   kitchen create   It creates a docker container with  centos-6.8 .   kitchen list   To list the available instances and their information.", 
            "title": "Create a Local Environment with Docker"
        }, 
        {
            "location": "/04_cookbooks/#adding-recipe-to-run_list", 
            "text": "Once the test environment created we need to add recipes to the run_list for testing it.   Add both java and tomcat recipes to run_list in  .kitchen.yml .  java::install  tomcat::install  tomcat::service   suites:\n  - name: default\n    run_list:\n      - recipe[java::install]\n      - recipe[tomcat::install]\n      - recipe[tomcat::service]", 
            "title": "Adding recipe to run_list"
        }, 
        {
            "location": "/04_cookbooks/#apply-chef-cookbooks", 
            "text": "Once the instance is created it can be converged along with the  run_list  specified in  .kitchen.yml   kitchen converge   It will  install chef  and then will apply run_list to the instances.  To verify, Login and check for java installation and version.   kitchen login   Logins to docker instance created by kitchen.   which java\njava -version\nwhich tomcat\nservice tomcat status", 
            "title": "Apply Chef Cookbooks"
        }, 
        {
            "location": "/04_cookbooks/#destroying-and-converging", 
            "text": "If you wish to re create the environment from scratch, use kitchen destroy followed by kitchen converge   kitchen destroy\nkitchen list\nkitchen converge   Run converge command directly to  create  a instance and then  converge  it and apply  run_list  to it.   Verify  the converge by visiting  http://ipaddress:8080  for tomcat homepage.", 
            "title": "Destroying and Converging"
        }, 
        {
            "location": "/04_cookbooks/#simplifying-run_list", 
            "text": "Lets make recipes simplified.  From this recipie  ./myapp/cookbooks/tomcat/recipes/default.rb  call all other recipes.   #\n# Cookbook Name:: tomcat\n# Recipe:: default\n#\n# Copyright (c) 2017 The Authors, All Rights Reserved.\n\ninclude_recipe 'java'\n# we can also call the above recipe as\n# include_recipe 'java::default'\n\ninclude_recipe 'tomcat::install'\ninclude_recipe 'tomcat::service'   Now change the run_list in  ./sysfoo/test/.kitchen.yml  and add only  tomcat::default   suites:\n  - name: default\n    run_list:\n      - recipe[tomcat]   Once added, now converge again.  You could get error because of java cookbook not found, but tomcat includes java in run_list.  Now to add  depended java , add java dependency entry in the metadata file  ./myapp/cookbooks/tomcat/metadata.rb .   name 'tomcat'\nmaintainer 'The Authors'\nmaintainer_email 'you@example.com'\nlicense 'all_rights'\ndescription 'Installs/Configures tomcat'\nlong_description 'Installs/Configures tomcat'\nversion '0.1.0'\n\ndepends 'java'", 
            "title": "Simplifying Run_list"
        }, 
        {
            "location": "/04_cookbooks/#managing-files", 
            "text": "We will need to manage configurations eg. tomcat.conf  since chef is a centralized configuration management system, we will keep the files centrally in cookbooks, which will then be copied to all managed nodes", 
            "title": "Managing Files"
        }, 
        {
            "location": "/04_cookbooks/#generating-files", 
            "text": "Create  tomcat.conf  to manage the configuration of tomcat in all nodes.  Use  chef generate file  in tomcat cookbook directory.   chef generate file cookbooks/tomcat tomcat.conf   Now  ./sysfoo/cookbooks/tomcat/files/default/tomcat.conf  is generated using chef.  Update  tomcat.conf  with the following content to manage tomcat.   TOMCAT_CFG_LOADED= 1 \n\nJAVA_HOME= /usr/lib/jvm/jre \nJAVA_OPTS= -Xms64m -Xmx128m -XX:MaxPermSize=128M  \\\n-Djava.security.egd=file:/dev/./urandom \n\nCATALINA_BASE= /usr/share/tomcat \nCATALINA_HOME= /usr/share/tomcat \nJASPER_HOME= /usr/share/tomcat \nCATALINA_TMPDIR= /var/cache/tomcat/temp \n\nTOMCAT_USER= tomcat \n\nSECURITY_MANAGER= false \n\nSHUTDOWN_WAIT= 30 \n\nSHUTDOWN_VERBOSE= false \n\nCATALINA_PID= /var/run/tomcat.pid   {todo}\nTIP: files/default", 
            "title": "Generating Files"
        }, 
        {
            "location": "/04_cookbooks/#recipe-to-manage-cookbook-files", 
            "text": "Now to manage  tomcat.conf  create a recipe called  config.rb  in tomcat cookbook.  Use  chef generate recipe  to generate recipe intomcat cookbook.   chef generate recipe cookbooks/tomcat config   Now  ./myapp/cookbooks/tomcat/recipes/config.rb  is generated.  Add the following content into  config.rb   cookbook_file '/etc/tomcat/tomcat.conf' do\n  source 'tomcat.conf'\n  owner 'tomcat'\n  group 'tomcat'\n  mode  0644\n  action :create\nend", 
            "title": "Recipe to manage cookbook files"
        }, 
        {
            "location": "/04_cookbooks/#refreshing-services", 
            "text": "We can use   notifies  with  timers  to trigger another resources in a recipes.  Let us add an entry to  notifies tomcat service  in  config.rb   cookbook_file '/etc/tomcat/tomcat.conf' do\n  source 'tomcat.conf'\n  owner 'tomcat'\n  group 'tomcat'\n  mode  0644\n  action :create\n  notifies :restart, 'service[tomcat]', :delayed\nend   In the above  service tomcat  will be restarted if there is any change in  cookbook_file  resource.  once  config.rb  recipe is created add an entry for run_list in  default.rb  of tomcat cookbook for applying it to nodes, as follows.   include_recipe 'tomcat::config'   Now  kitchen converge  and check logs to see  service tomcat  is being  restarted  for every change made in  tomcat.conf  file.  Now verify by logging into docker instance using  kitchen login .   [^devopsguru_blog]: Devopsguru Blog - http://devopsguru.tumblr.com/post/147717124737/chef-generate-app-vs-chef-generate-cookbook-vs", 
            "title": "Refreshing Services"
        }, 
        {
            "location": "/05_tdd_with_test_kitchen/", 
            "text": "TDD with Test Kitchen\n\n\nApp test vs Cookbook Test\n\n\n\n\n\n\nTest configuration can be defined in two different places.\n\n\nOne is inside app directory \nmyapp/test/recipes/default_test.rb\n\n\nAnother one is inside the cookbooks directory \nmyapp/cookbooks/mycookbook/test/recipes/default_test.rb\n\n\n\n\nInspec vs Serverspec\n\n\n\n\nInspec \nresources\n\n\nServerspec \nresources\n\n\n\n\nCreating test file\n\n\nUser Resource\n\n\n\n\nAdd \ninspec user resource\n to check for \ntomcat user\n\n\n\n\nunless os.windows?\n  describe user('tomcat') do\n    it { should exist }\n  end\nend\n\n\n\n\nPort Resource\n\n\n\n\nAdd \ninspec port resource\n to verify listening of port \n8080\n\n\nInclude protocols for \ntcp6\n\n\n\n\ndescribe port(8080) do\n  it { should be_listening }\n  its('protocols') { should include 'tcp6' }\nend\n\n\n\n\nService Resource\n\n\n\n\nAdd \ninspec service resource\n to verify \ntomcat service\n\n\nInclude \ninstalled\n, \nenabled\n and \nrunning\n conditions\n\n\n\n\ndescribe service('tomcat') do\n  it { should be_installed }\n  it { should be_enabled }\n  it { should be_running }\nend\n\n\n\n\nComplete file of \n/workspace/myapp/test/recipes/default_test.rb\n is as follows\n\n\nunless os.windows?\n  describe user('tomcat') do\n    it { should exist }\n  end\nend\n\ndescribe port(8080) do\n  it { should be_listening }\n  its('protocols') { should include 'tcp6' }\nend\n\ndescribe service('tomcat') do\n  it { should be_installed }\n  it { should be_enabled }\n  it { should be_running }\nend", 
            "title": "TDD with Test Kitchen"
        }, 
        {
            "location": "/05_tdd_with_test_kitchen/#tdd-with-test-kitchen", 
            "text": "", 
            "title": "TDD with Test Kitchen"
        }, 
        {
            "location": "/05_tdd_with_test_kitchen/#app-test-vs-cookbook-test", 
            "text": "Test configuration can be defined in two different places.  One is inside app directory  myapp/test/recipes/default_test.rb  Another one is inside the cookbooks directory  myapp/cookbooks/mycookbook/test/recipes/default_test.rb", 
            "title": "App test vs Cookbook Test"
        }, 
        {
            "location": "/05_tdd_with_test_kitchen/#inspec-vs-serverspec", 
            "text": "Inspec  resources  Serverspec  resources", 
            "title": "Inspec vs Serverspec"
        }, 
        {
            "location": "/05_tdd_with_test_kitchen/#creating-test-file", 
            "text": "", 
            "title": "Creating test file"
        }, 
        {
            "location": "/05_tdd_with_test_kitchen/#user-resource", 
            "text": "Add  inspec user resource  to check for  tomcat user   unless os.windows?\n  describe user('tomcat') do\n    it { should exist }\n  end\nend", 
            "title": "User Resource"
        }, 
        {
            "location": "/05_tdd_with_test_kitchen/#port-resource", 
            "text": "Add  inspec port resource  to verify listening of port  8080  Include protocols for  tcp6   describe port(8080) do\n  it { should be_listening }\n  its('protocols') { should include 'tcp6' }\nend", 
            "title": "Port Resource"
        }, 
        {
            "location": "/05_tdd_with_test_kitchen/#service-resource", 
            "text": "Add  inspec service resource  to verify  tomcat service  Include  installed ,  enabled  and  running  conditions   describe service('tomcat') do\n  it { should be_installed }\n  it { should be_enabled }\n  it { should be_running }\nend  Complete file of  /workspace/myapp/test/recipes/default_test.rb  is as follows  unless os.windows?\n  describe user('tomcat') do\n    it { should exist }\n  end\nend\n\ndescribe port(8080) do\n  it { should be_listening }\n  its('protocols') { should include 'tcp6' }\nend\n\ndescribe service('tomcat') do\n  it { should be_installed }\n  it { should be_enabled }\n  it { should be_running }\nend", 
            "title": "Service Resource"
        }, 
        {
            "location": "/06_multi_node_cluster_setup/", 
            "text": "Multi Node Cluster\n\n\nIn this session  we going to simulate a realistic environment with multiple nodes being managed with Chef Server, similar to most of the real world implementations.\n\n\nThis would include 3 components,\n\n\n\n\nChef Workstation (Could be your personal PC/Laptop)  \n\n\nChef Server (Hosted or On-Premises )  \n\n\nChef Clients ('n' number of machines; could be VM, AWS EC2, etc..)  \n\n\n\n\n\n\nSetting up Hosted Chef Server Environment\n\n\nChef server comes in two flavors\n  * Open Source\n  * Enterprise\n\n\nEnterprise version of chef has two sub types\n  * Hosted\n  * On Premises\n\n\nIn terms of features, both on prem and hosted versions are the same. The only difference is whether you use the SaaS solution from Chef, or you want to host it in house.  \n\n\nFor this workshop, we would be using \nHosted Enterprise Chef\n for the following reasons,\n\n\n\n\nEase of setup : hosted version is a breeze to setup and you have a working chef server setup within minutes\n\n\nResource Optimization: On Premises version of chef server takes a lot of resources to setup and use e.g. 4GB of RAM with atleast dual core for getting a decent operational version. Thats too much in most learning lab environments. Hosted version takes zero resources to setup.  \n\n\n\n\nLets learn how to setup our hosted chef account...\n\n\nCreating an Account\n\n\n\n\nNow let us create a account in \nchef.io\n to manage our own hosted chef server.  \n\n\nOnce account is created, verify and login.  \n\n\nNow create a organization of your own and then download chef-starter kit.  \n\n\n\n\nSetting Up Workstation\n\n\n\n\nUpload  starter kit to the workspace. Its the \nchef-starter.zip\n file that you downloaded from chef server.  \n\n\nUpload the file to workspace and extract it. You should see \nchef-repo\n directory created after being extracted.  \n\n\nChange into chef-repo directory created as the outcome of above command and validate workstation by running  \n\n\n\n\nknife client list\n\n\n\n\nThe above command will return the \norgname-validator\n client. If it does,you have successufully validated all of following,  \n\n\n\n\nWorkstation software (knife) is installed  \n\n\nYou have required configurations, authentication keys/credentials to talk to Chef Server  \n\n\nChef Server is setup and ready\n\n\nWorkstation is able to communicate with Chef Server. There are no network issues etc.  \n\n\nWorkstaiton is able to authenticate with Chef Server  \n\n\nWorkstation has made the API request and displays  the results returned by Chef Server  \n\n\n\n\n\n\nMoving knife configs to workspace\n\n\n\n\nCopy \n.chef\n directory from \nchef-repo\n to \nworkspace\n.\n\n\n\n\n\nmv /workspace/chef-repo/.chef  /workspace\n\n\n\n\n\nAlternately you could also create a symbolic link/symlink.\n\n\nFrom here on all  \nknife\n commands work from any subdirectory of /workspace.\n\n\nBootstrapping a Managed Node\n\n\n\n\nNow run \nknife client list\n to get the list of client associated with the hosted chef-server.\n\n\nIn our case we don't have any client as of now, so lets start adding nodes by using \nknife bootstrap\n command.\n\n\nFrom Workstation we need to bootstrap client.\n\n\nIn codespaces environment we have pre-built nodes associated with the following IP.\n\n\n\n\n\n\n\n\n\n\nNode\n\n\nName\n\n\nIP\n\n\nPort Mapping\n\n\n\n\n\n\n\n\n\n\nnode1\n\n\napp1\n\n\n177.0.101.10\n\n\n8081:8080\n\n\n\n\n\n\nnode2\n\n\napp2\n\n\n177.0.101.11\n\n\n8082:8080\n\n\n\n\n\n\nnode3\n\n\napp3\n\n\n177.0.101.12\n\n\n8083:8080\n\n\n\n\n\n\nnode4\n\n\nlb\n\n\n177.0.101.13\n\n\n8084:8080\n\n\n\n\n\n\n\n\n\n\n\n\nAll nodes are accessible using ssh without password.\n\n\n\n\n\n\nLets bootstrap node1 using the following command\n\n\n\n\n\n\nknife bootstrap node1 --ssh-user devops --sudo -N app1\n\n\n\n\n\n\nHere \n-N\n is used to define the name of the node that we bootstrap.\n\n\n--ssh-user\n is used to provide the name of the user in that particular node.\n\n\nAlso using \n--sudo\n to connect is to provide root previlages for running all the command.\n\n\n\n\napp1\n is bootstrapped successfully.\n\n\n\n\n\n\nNow check for the available nodes\n\n\n\n\n\n\nknife node list\n\n\n\n\n\n\nCheck for the existing status and specified runlist for node1(app1)\n\n\n\n\nknife node show app1\n\n\n\n\nProviding configurations to the Node\n\n\nTo provide configurations, you would need to upload the cookbooks to chef server and set the run list.\n\n\nBefore we do so, we also need to updated the path where knife would look in to find the cookbooks.\n\n\nEdit /workspace/.chef/knife.rb\n\nand update cookbook_path from\n\n\ncookbook_path  [\n#{current_dir}/../cookbooks\n]\n\n\n\n\n\nto\n\n\ncookbook_path       [\ncookbooks\n]\n\n\n\n\n\nChange into chapter6/sysfoo directory on workstation.\n\n\nUpload the  cookbooks that we created and tested locally earlier.\n\n\nknife cookbook upload java tomcat\n\n\n\n\n\nDefining Run List for the Node\n\n\nknife node show app1\nknife node run_list add app1 \nrecipe[tomcat]\n\n\n\n\n\nTo apply, login to node1 and run chef-client\n\n\nssh devops@node1\nsudo chef-client\n\n\n\n\nManaging Chef Client as a Service\n\n\nLets now start managing chef-client and its configurations through chef cookbooks.  We have a special purpose cookbook by name \nchef-client\n which allows us to do so.  It will,\n  * decide how to run chef-client, eg. cronjob, service etc.\n  * does support   various types of service managers e.g. runit, bluepill, supervisord etc.\n  * manages configurations for chef client .eg. how frequently chef-client runs\n\n\nLets upload chef-client cookbook which is already present if you are using the code repository provides.\n\n\nknife cookbook upload chef-client\n\n\n\n\n\nDid chef-client cookbook get uploaded successfully?   If not, observe the error and try to deduct the root cause.\n\n\nBerkshelf\n\n\nBerkshelf is a dependency manager for Chef cookbooks. With it, you can easily depend on community cookbooks and have them safely included in your workflow. You can also ensure that your CI systems reproducibly select the same cookbook versions, and can upload and bundle cookbook dependencies without needing a locally maintained copy. Berkshelf is included in the Chef Development Kit.\n\n\n\n\nNow look into the downloaded \nchef-client\n cookbook.\n\n\nIt has \nberksfile\n where the dependent cookbook are mentioned.\n\n\nTo run \nberks\n command we need to be in the directory where berksfile is located, that is \nworkspace/sysfoo/cookbooks/chef-client\n\n\nNow run install and upload command.\n\n\n\n\ncd cookbooks/chef-client\n\nberks install; berks upload\n\ncd ../..\n\n\n\n\n\nLets now add \nchef-client\n recipe to the runlist of node1.\n\n\nknife node run_list add app1 \nrecipe[chef-client]\n\n\n\n\n\nTo apply this recipe, login to \nnode1\n and run chef client as,\n\n\nssh devops@node1\nsudo chef-client\n\n\n\n\nProviding run list while bootstrapping\n\n\nFor node1, we did the following,\n  * Bootstrapped the node\n  * Defined run list\n  * Logged in to the node and run chef-client\n\n\nFor initial node this was needed as you  are learning to apply one concept at a time, and you did not have the cookbooks uploaded on the server. Now that its all ready, you could combine these operations into one by defining the run list, right at the bootstrap time.  \n\n\nLets bootstrap \nnode2\n this time with tomcat and java configs\n\n\nknife bootstrap node2 -x devops --sudo -N app2 -r \nrecipe[tomcat],recipe[chef-client]\n\n\n\n\n\n\n\n--run-list\n is used to specify run-list and by applying recipes to the node at the time of bootstrap.\n\n\nNow verify by visiting host ip with port mapping of 8080 to 8081 for node1 http://ip:8081 and port mapping of 8080 to 8082 for node2 http://ip:8082, where the tomcat application is installed and service is up and running.", 
            "title": "Setting up a Multi Node Cluster"
        }, 
        {
            "location": "/06_multi_node_cluster_setup/#multi-node-cluster", 
            "text": "In this session  we going to simulate a realistic environment with multiple nodes being managed with Chef Server, similar to most of the real world implementations.  This would include 3 components,   Chef Workstation (Could be your personal PC/Laptop)    Chef Server (Hosted or On-Premises )    Chef Clients ('n' number of machines; could be VM, AWS EC2, etc..)", 
            "title": "Multi Node Cluster"
        }, 
        {
            "location": "/06_multi_node_cluster_setup/#setting-up-hosted-chef-server-environment", 
            "text": "Chef server comes in two flavors\n  * Open Source\n  * Enterprise  Enterprise version of chef has two sub types\n  * Hosted\n  * On Premises  In terms of features, both on prem and hosted versions are the same. The only difference is whether you use the SaaS solution from Chef, or you want to host it in house.    For this workshop, we would be using  Hosted Enterprise Chef  for the following reasons,   Ease of setup : hosted version is a breeze to setup and you have a working chef server setup within minutes  Resource Optimization: On Premises version of chef server takes a lot of resources to setup and use e.g. 4GB of RAM with atleast dual core for getting a decent operational version. Thats too much in most learning lab environments. Hosted version takes zero resources to setup.     Lets learn how to setup our hosted chef account...", 
            "title": "Setting up Hosted Chef Server Environment"
        }, 
        {
            "location": "/06_multi_node_cluster_setup/#creating-an-account", 
            "text": "Now let us create a account in  chef.io  to manage our own hosted chef server.    Once account is created, verify and login.    Now create a organization of your own and then download chef-starter kit.", 
            "title": "Creating an Account"
        }, 
        {
            "location": "/06_multi_node_cluster_setup/#setting-up-workstation", 
            "text": "Upload  starter kit to the workspace. Its the  chef-starter.zip  file that you downloaded from chef server.    Upload the file to workspace and extract it. You should see  chef-repo  directory created after being extracted.    Change into chef-repo directory created as the outcome of above command and validate workstation by running     knife client list  The above command will return the  orgname-validator  client. If it does,you have successufully validated all of following,     Workstation software (knife) is installed    You have required configurations, authentication keys/credentials to talk to Chef Server    Chef Server is setup and ready  Workstation is able to communicate with Chef Server. There are no network issues etc.    Workstaiton is able to authenticate with Chef Server    Workstation has made the API request and displays  the results returned by Chef Server", 
            "title": "Setting Up Workstation"
        }, 
        {
            "location": "/06_multi_node_cluster_setup/#moving-knife-configs-to-workspace", 
            "text": "Copy  .chef  directory from  chef-repo  to  workspace .   \nmv /workspace/chef-repo/.chef  /workspace  Alternately you could also create a symbolic link/symlink.  From here on all   knife  commands work from any subdirectory of /workspace.", 
            "title": "Moving knife configs to workspace"
        }, 
        {
            "location": "/06_multi_node_cluster_setup/#bootstrapping-a-managed-node", 
            "text": "Now run  knife client list  to get the list of client associated with the hosted chef-server.  In our case we don't have any client as of now, so lets start adding nodes by using  knife bootstrap  command.  From Workstation we need to bootstrap client.  In codespaces environment we have pre-built nodes associated with the following IP.      Node  Name  IP  Port Mapping      node1  app1  177.0.101.10  8081:8080    node2  app2  177.0.101.11  8082:8080    node3  app3  177.0.101.12  8083:8080    node4  lb  177.0.101.13  8084:8080       All nodes are accessible using ssh without password.    Lets bootstrap node1 using the following command    knife bootstrap node1 --ssh-user devops --sudo -N app1   Here  -N  is used to define the name of the node that we bootstrap.  --ssh-user  is used to provide the name of the user in that particular node.  Also using  --sudo  to connect is to provide root previlages for running all the command.   app1  is bootstrapped successfully.    Now check for the available nodes    knife node list   Check for the existing status and specified runlist for node1(app1)   knife node show app1", 
            "title": "Bootstrapping a Managed Node"
        }, 
        {
            "location": "/06_multi_node_cluster_setup/#providing-configurations-to-the-node", 
            "text": "To provide configurations, you would need to upload the cookbooks to chef server and set the run list.  Before we do so, we also need to updated the path where knife would look in to find the cookbooks.  Edit /workspace/.chef/knife.rb \nand update cookbook_path from  cookbook_path  [ #{current_dir}/../cookbooks ]  to  cookbook_path       [ cookbooks ]  Change into chapter6/sysfoo directory on workstation.  Upload the  cookbooks that we created and tested locally earlier.  knife cookbook upload java tomcat", 
            "title": "Providing configurations to the Node"
        }, 
        {
            "location": "/06_multi_node_cluster_setup/#defining-run-list-for-the-node", 
            "text": "knife node show app1\nknife node run_list add app1  recipe[tomcat]   To apply, login to node1 and run chef-client  ssh devops@node1\nsudo chef-client", 
            "title": "Defining Run List for the Node"
        }, 
        {
            "location": "/06_multi_node_cluster_setup/#managing-chef-client-as-a-service", 
            "text": "Lets now start managing chef-client and its configurations through chef cookbooks.  We have a special purpose cookbook by name  chef-client  which allows us to do so.  It will,\n  * decide how to run chef-client, eg. cronjob, service etc.\n  * does support   various types of service managers e.g. runit, bluepill, supervisord etc.\n  * manages configurations for chef client .eg. how frequently chef-client runs  Lets upload chef-client cookbook which is already present if you are using the code repository provides.  knife cookbook upload chef-client  Did chef-client cookbook get uploaded successfully?   If not, observe the error and try to deduct the root cause.", 
            "title": "Managing Chef Client as a Service"
        }, 
        {
            "location": "/06_multi_node_cluster_setup/#berkshelf", 
            "text": "Berkshelf is a dependency manager for Chef cookbooks. With it, you can easily depend on community cookbooks and have them safely included in your workflow. You can also ensure that your CI systems reproducibly select the same cookbook versions, and can upload and bundle cookbook dependencies without needing a locally maintained copy. Berkshelf is included in the Chef Development Kit.   Now look into the downloaded  chef-client  cookbook.  It has  berksfile  where the dependent cookbook are mentioned.  To run  berks  command we need to be in the directory where berksfile is located, that is  workspace/sysfoo/cookbooks/chef-client  Now run install and upload command.   cd cookbooks/chef-client\n\nberks install; berks upload\n\ncd ../..  Lets now add  chef-client  recipe to the runlist of node1.  knife node run_list add app1  recipe[chef-client]   To apply this recipe, login to  node1  and run chef client as,  ssh devops@node1\nsudo chef-client", 
            "title": "Berkshelf"
        }, 
        {
            "location": "/06_multi_node_cluster_setup/#providing-run-list-while-bootstrapping", 
            "text": "For node1, we did the following,\n  * Bootstrapped the node\n  * Defined run list\n  * Logged in to the node and run chef-client  For initial node this was needed as you  are learning to apply one concept at a time, and you did not have the cookbooks uploaded on the server. Now that its all ready, you could combine these operations into one by defining the run list, right at the bootstrap time.    Lets bootstrap  node2  this time with tomcat and java configs  knife bootstrap node2 -x devops --sudo -N app2 -r  recipe[tomcat],recipe[chef-client]    --run-list  is used to specify run-list and by applying recipes to the node at the time of bootstrap.  Now verify by visiting host ip with port mapping of 8080 to 8081 for node1 http://ip:8081 and port mapping of 8080 to 8082 for node2 http://ip:8082, where the tomcat application is installed and service is up and running.", 
            "title": "Providing run list while bootstrapping"
        }, 
        {
            "location": "/07_data_driven_cookbooks_attr_templates/", 
            "text": "Data Driven Cookbooks\n\n\nCode vs Data\n\n\n\n\n\n\nonce the data is taken out of the code then cookbook become generic.\n\n\nGeneric cookbook can be used with any OS and environments.\n\n\nReusability helps in reducing tonnes and tonnes of time.\n\n\n\n\nNode Object\n\n\n\n\nIt is the representation of each node on chef server in \nJSON\n format.\n\n\nIf we run a \nchef-client\n it generates a node object in chef server in case of nodes or in workstation (\n/nodes/*.json\n) in case of running locally in workstation.\n\n\n\n\nAttributes\n\n\nIt is used to specify a detail about node.\n- Attributes are used by the chef-client to understand;\n - The current state of the node\n - What the state of the node was at the end of the previous chef-client run\n - What the state of the node should be at the end of the current chef-client run\n- \nAttributes\n are taken in precedence, according to the place where we specify them, as follows;\n\n\nSystem Defined Attributes\n\n\nOHAI\n\n\n\n\nIt installs along with \nchef-client\n.\n\n\nIt helps in getting all the information about nodes\n\n\nFinding information on node with ohai\n\n\n\n\nohai\nohai ipaddress\nohai hostname\nohai memory\nohai memory/total\nohai cpu/model_name\n\n\n\n\n\n\nReferring attributes\n\n\n\n\nnode['ipaddress']\nnode['hostname']\nnode['memory']['total']\nnode['cpu']['model_name']\n\n\n\n\nUser Defined Attributes\n\n\n\n\nUser defined attributes are located in four places as follows\n\n\nAttributes file\n\n\nRecipes\n\n\nRoles\n\n\nEnvironments\n\n\n\n\nAttribute File\n\n\n\n\nHow the attribute file looks like?\n\n\n\n\n\n\n\n\nPrecedence is defined\n\n\n\n\nAttribute and its value is defined as per the above format.\n\n\n\n\n\n\nNow we can access these attributes in \nrecipe\n or \ntemplate\n as shown below.\n\n\n\n\n\n\n\n\nExample\n\n\ntemplate node['tomcat']['config'] do\n  source 'tomcat.conf.erb'\n  owner node['tomcat']['user']\n  group node['tomcat']['group']\n  mode '0644'\n  action :create\n  notifies :restart, \nservice[#{node['tomcat']['service']}]\n, :delayed\nend\n\n\n\n\nParameterizing Tomcat Configurations\n\n\n\n\nNow let us start creating attribute file\n\n\nUse \nchef generate\n to create a file in tomcat cookbook\n\n\n\n\nchef generate attribute cookbooks/tomcat default\n\n\n\n\n\n\nIt will create a file as follows \ncookbooks/tomcat/attributes/default.rb\n\n\nNow we add the attributes and its value in \ndefault.rb\n\n\nPath: \ncookbooks/tomcat/attributes/default.rb\n\n\n\n\ndefault['tomcat']['user'] = 'tomcat'\ndefault['tomcat']['group'] = 'tomcat'\ndefault['tomcat']['config'] = '/etc/tomcat/tomcat.conf'\ndefault['tomcat']['packages'] = [ 'tomcat', 'tomcat-webapps' ]\ndefault['tomcat']['service'] = 'tomcat'\n\n\n\n\n\n\nNow call these attributes in the following recipes\n\n\ntomcat::config\n will be changed as follows\n\n\n\n\ncookbook_file node['tomcat']['config'] do\n  source 'tomcat.conf'\n  owner node['tomcat']['user']\n  group node['tomcat']['group']\n  mode '0644'\n  action :create\n  notifies :restart, \nservice[#{node['tomcat']['service']}]\n, :delayed\nend\n\n\n\n\n\n\ntomcat::install\n will be changed as follows\n\n\n\n\npackage node['tomcat']['packages']\n\n\n\n\n\n\ntomcat::service\n will be changed as follows\n\n\n\n\nservice node['tomcat']['service'] do\n   action [ :start, :enable]\nend\n\n\n\n\n\n\nNow apply it using \nkitchen converge\n and then verify using \nkitchen verify\n.\n\n\n\n\nPlatform Specific cookbooks\n\n\n\n\nLet us convert our first created \nbase.rb\n recipe into a cookbook.\n\n\nCreate a cookbook using \nchef generate\n\n\n\n\nchef generate cookbook cookbooks/base\n\n\n\n\n\n\nNow move the \nbase.rb\n to \ndefault.rb\n of base cookbook.\n\n\n\n\nmv /workspace/chapter3/base.rb cookbooks/base/recipes/default.rb\n\n\n\n\n\n\nAdd \nbase::default\n recipe to the run_list\n\n\n\n\nknife node run_list add app1 \nrecipe[base]\n\n\n\n\n\n\n\nApply on node1\n\n\n\n\nssh devops@node1\nsudo chef-client\n\n\n\n\n\n\nIt fails\n because the service name for rhel/centos is \nntpd\n and \nnot ntp\n as like debian.\n\n\n\n\n\n\n\n\nTo overcome this we use attribute for platform specific.\n\n\nWe use system defined attribute \nplatform_family\n to do this.\n\n\n\n\nExample\n for \nohai platform_family\n is\n\n\nroot@ws:/workspace/myapp# ohai platform_family\n[\n  \ndebian\n\n]\nroot@ws:/workspace/myapp# kitchen login\nLast login: Thu May  4 05:50:20 2017 from 172.17.0.1\n[kitchen@9af3a004e202 ~]$ ohai platform_family\n[2017-05-04T05:58:19+00:00] INFO: The plugin path /etc/chef/ohai/plugins\ndoes not exist. Skipping...\n[\n  \nrhel\n\n]\n[kitchen@9af3a004e202 ~]$ logout\nConnection to localhost closed.\nroot@ws:/workspace/myapp#\n\n\n\n\n\n\nNow let us create a create a \ndefault attribute\n file for base cookbook using \nchef generate\n\n\n\n\nchef generate attribute cookbooks/base default\n\n\n\n\n\n\nNow add the following content to attribute file\n\n\nPath: \ncookbooks/base/attributes/default.rb\n\n\n\n\ncase node['platform_family']\nwhen 'rhel'\n  default['ntp']['service'] = 'ntpd'\nelse\n  default['ntp']['service'] = 'ntp'\nend\n\n\n\n\n\n\nCall the attributes in \ncookbooks/base/recipes/default.rb\n recipe\n\n\n\n\nservice node['ntp']['service'] do\n  action [ :start, :enable ]\nend\n\n\n\n\n\n\nNow apply again using kitchen\n\n\n\n\nssh devop@node1\nsudo chef-client\n\n\n\n\n\n\nIt is successful now and service is started based on platform.\n\n\n\n\nNano Project\n - Add some tests for recipes in base cookbook for different platform.\n\n\nTemplates\n\n\n\n\nA cookbook template is an Embedded Ruby (ERB) template that is used to dynamically generate static text files.\n\n\nTemplates are great way to manage configuration files for different environment.\n\n\nERB or ERUBIS\n\n\nContains text with dynamic ruby code\n\n\nUses tags to mark dynamic code\n\n\nERB Tags\n\n\nCode wrapped in \n% %\n or \n% -%\n is a statement that is evaluated.\n\n\nCode wrapped in \n%= %\n is code that is evaluated and the result is placed into the file.\n\n\nHarcoded strings dont have to be wrapped in erb tags if they are constant, but Ruby code must be wrapped in erb tags if you want the result of that code to go into your file.\n\n\n\n\nTemplatize MOTD\n\n\n\n\nGenerate \nmotd\n template for \nbase cookbook\n.\n\n\n\n\nchef generate template cookbooks/base motd\n\n\n\n\n\n\nAdd the following content to the template file \nmotd.erb\n.\n\n\nPath: \ncookbooks/base/templates/default/motd.erb\n\n\n\n\nThis server is a property of \n%= node['org']['name'] %\n\n\n      SYSTEM INFO:\n\n       HOSTNAME   : \n%= node['hostname'] %\n\n       IP ADDRESS : \n%= node['ipaddress'] %\n\n       MEMORY     : \n%= node['memory']['total'] %\n\n\n\n\n\n\n\nNow add organization name as a user defined attribute in \nattribute file\n\n\nPath: \ncookbooks/base/attributes/default.rb\n\n\n\n\ndefault['org']['name'] = \nXYZ Inc.\n\n\n\n\n\n\n\nComplete attribute \ndefault.rb\n of \nbase cookbook\n is as follows\n\n\n\n\ncase node['platform_family']\nwhen 'rhel'\n  default['ntp']['service'] = 'ntpd'\nelse\n  default['ntp']['service'] = 'ntp'\nend\n\ndefault['org']['name'] = \nXYZ Inc.\n\n\n\n\n\n\n\nNow add template resource to the \ncookbooks/base/recipes/default.rb\n recipe file.\n\n\n\n\ntemplate '/etc/motd' do\n  source 'motd.erb'\n  owner 'root'\n  group 'root'\n  mode  0644\nend\n\n\n\n\n\n\nApply using \nkitchen converge\n.\n\n\n\n\nAttributes Precedence\n\n\n\n\nDeclaring attributes in various places takes precedence one over another.\n\n\n\n\n\n\n\n\nLet us take an example of declaring port as follows\n\n\n\n\n\n\n\n\nNow let us define organization name in recipe file, before calling attribute in any resource of a recipe.\n\n\nPath: \ncookbooks/base/recipes/default.rb\n\n\n\n\nnode.default['org']['name'] = \nSchool of Devops\n\n\n\n\n\n\n\nComplete recipe \ndefault.rb\n of \nbase cookbook\n is as follows\n\n\n\n\nuser 'deploy' do\n  uid 5001\n  home '/home/deploy'\n  action :create\n  password '$1$Ze1eJK3R$j5I0NRP5WxbZAaeXcfYW7/'\nend\n\nuser 'dojo' do\n  action :remove\nend\n\npackage 'ntp' do\n  action :install\nend\n\npackage ['tree', 'unzip', 'wget'] do\n  action :install\nend\n\npackage 'git'\n\nservice node['ntp']['service'] do\n  action [ :start, :enable ]\nend\n\nnode.default['org']['name'] = \nSchool of Devops Inc\n\n\ntemplate '/etc/motd' do\n  source 'motd.erb'\n  owner 'root'\n  group 'root'\n  mode  0644\nend\n\n\n\n\n\n\nNow apply using \nkitchen converge\n\n\n\n\nTemplatizing Tomcat Cookbook (LAB Exercise)\n\n\n\n\nGenerate a \ntomcat.conf.erb\n template for tomcat cookbook.\n\n\n\n\nchef generate template cookbooks/tomcat tomcat.conf\n\n\n\n\n\n\nGenerate a \ndefault.rb\n attribute for tomcat cookbook.\n\n\n\n\nchef generate attribute cookbooks/tomcat default\n\n\n\n\n\n\nAdd the following content to attribute file.\n\n\nPath: \n/workspace/myapp/cookbooks/tomcat/attributes/default.rb\n\n\n\n\ndefault['tomcat']['user'] = 'tomcat'\ndefault['tomcat']['group'] = 'tomcat'\ndefault['tomcat']['config'] = '/etc/tomcat/tomcat.conf'\ndefault['tomcat']['packages'] = [ 'tomcat', 'tomcat-webapps' ]\ndefault['tomcat']['service'] = 'tomcat'\ndefault['tomcat']['user'] = 'tomcat'\ndefault['tomcat']['group'] = 'tomcat'\ndefault['tomcat']['java_home'] = '/usr/lib/jvm/jre'\ndefault['tomcat']['catalina_home'] = '/usr/share/tomcat'\ndefault['tomcat']['java_opts'] = '-Xms32m -Xmx64m -XX:MaxPermSize=64M  \\\n-Djava.security.egd=file:/dev/./urandom'\n\n\n\n\n\n\nAdd the below content to \ntomcat.conf.erb\n template.\n\n\nPath: \n/workspace/myapp/cookbooks/tomcat/templates\n\n\n\n\nTOMCAT_CFG_LOADED=\n1\n\n\nJAVA_HOME=\n%= node['tomcat']['java_home'] %\n\nJAVA_OPTS=\n%= node['tomcat']['java_opts'] %\n\n\nCATALINA_BASE=\n/usr/share/tomcat\n\nCATALINA_HOME=\n%= node['tomcat']['catalina_home'] %\n\nJASPER_HOME=\n/usr/share/tomcat\n\nCATALINA_TMPDIR=\n/var/cache/tomcat/temp\n\n\nTOMCAT_USER=\n%= node['tomcat']['user'] %\n\n\nSECURITY_MANAGER=\nfalse\n\n\nSHUTDOWN_WAIT=\n30\n\n\nSHUTDOWN_VERBOSE=\nfalse\n\n\nCATALINA_PID=\n/var/run/tomcat.pid\n\n\n\n\n\n\n\nNow update \ntomcat::config\n recipe as mentioned below\n\n\nPath: \n/workspace/myapp/cookbooks/tomcat/recipes/config.rb\n\n\n\n\ntemplate node['tomcat']['config'] do\n  source 'tomcat.conf.erb'\n  owner node['tomcat']['user']\n  group node['tomcat']['group']\n  mode '0644'\n  action :create\n  notifies :restart, \nservice[#{node['tomcat']['service']}]\n, :delayed\nend\n\n\n\n\n\n\n\n\nApply using \nkitchen converge\n\n\n\n\n\n\nNow change the values of \nJAVA_OPTS\n in attribute file and then apply again for verifying the changes using template and attribute.\n\n\n\n\n\n\nAlso verify using \nkitchen login\n and run \nps auwwx\n command.", 
            "title": "Data Driven Cookbooks"
        }, 
        {
            "location": "/07_data_driven_cookbooks_attr_templates/#data-driven-cookbooks", 
            "text": "", 
            "title": "Data Driven Cookbooks"
        }, 
        {
            "location": "/07_data_driven_cookbooks_attr_templates/#code-vs-data", 
            "text": "once the data is taken out of the code then cookbook become generic.  Generic cookbook can be used with any OS and environments.  Reusability helps in reducing tonnes and tonnes of time.", 
            "title": "Code vs Data"
        }, 
        {
            "location": "/07_data_driven_cookbooks_attr_templates/#node-object", 
            "text": "It is the representation of each node on chef server in  JSON  format.  If we run a  chef-client  it generates a node object in chef server in case of nodes or in workstation ( /nodes/*.json ) in case of running locally in workstation.", 
            "title": "Node Object"
        }, 
        {
            "location": "/07_data_driven_cookbooks_attr_templates/#attributes", 
            "text": "It is used to specify a detail about node.\n- Attributes are used by the chef-client to understand;\n - The current state of the node\n - What the state of the node was at the end of the previous chef-client run\n - What the state of the node should be at the end of the current chef-client run\n-  Attributes  are taken in precedence, according to the place where we specify them, as follows;", 
            "title": "Attributes"
        }, 
        {
            "location": "/07_data_driven_cookbooks_attr_templates/#system-defined-attributes", 
            "text": "", 
            "title": "System Defined Attributes"
        }, 
        {
            "location": "/07_data_driven_cookbooks_attr_templates/#ohai", 
            "text": "It installs along with  chef-client .  It helps in getting all the information about nodes  Finding information on node with ohai   ohai\nohai ipaddress\nohai hostname\nohai memory\nohai memory/total\nohai cpu/model_name   Referring attributes   node['ipaddress']\nnode['hostname']\nnode['memory']['total']\nnode['cpu']['model_name']", 
            "title": "OHAI"
        }, 
        {
            "location": "/07_data_driven_cookbooks_attr_templates/#user-defined-attributes", 
            "text": "User defined attributes are located in four places as follows  Attributes file  Recipes  Roles  Environments", 
            "title": "User Defined Attributes"
        }, 
        {
            "location": "/07_data_driven_cookbooks_attr_templates/#attribute-file", 
            "text": "How the attribute file looks like?     Precedence is defined   Attribute and its value is defined as per the above format.    Now we can access these attributes in  recipe  or  template  as shown below.     Example  template node['tomcat']['config'] do\n  source 'tomcat.conf.erb'\n  owner node['tomcat']['user']\n  group node['tomcat']['group']\n  mode '0644'\n  action :create\n  notifies :restart,  service[#{node['tomcat']['service']}] , :delayed\nend", 
            "title": "Attribute File"
        }, 
        {
            "location": "/07_data_driven_cookbooks_attr_templates/#parameterizing-tomcat-configurations", 
            "text": "Now let us start creating attribute file  Use  chef generate  to create a file in tomcat cookbook   chef generate attribute cookbooks/tomcat default   It will create a file as follows  cookbooks/tomcat/attributes/default.rb  Now we add the attributes and its value in  default.rb  Path:  cookbooks/tomcat/attributes/default.rb   default['tomcat']['user'] = 'tomcat'\ndefault['tomcat']['group'] = 'tomcat'\ndefault['tomcat']['config'] = '/etc/tomcat/tomcat.conf'\ndefault['tomcat']['packages'] = [ 'tomcat', 'tomcat-webapps' ]\ndefault['tomcat']['service'] = 'tomcat'   Now call these attributes in the following recipes  tomcat::config  will be changed as follows   cookbook_file node['tomcat']['config'] do\n  source 'tomcat.conf'\n  owner node['tomcat']['user']\n  group node['tomcat']['group']\n  mode '0644'\n  action :create\n  notifies :restart,  service[#{node['tomcat']['service']}] , :delayed\nend   tomcat::install  will be changed as follows   package node['tomcat']['packages']   tomcat::service  will be changed as follows   service node['tomcat']['service'] do\n   action [ :start, :enable]\nend   Now apply it using  kitchen converge  and then verify using  kitchen verify .", 
            "title": "Parameterizing Tomcat Configurations"
        }, 
        {
            "location": "/07_data_driven_cookbooks_attr_templates/#platform-specific-cookbooks", 
            "text": "Let us convert our first created  base.rb  recipe into a cookbook.  Create a cookbook using  chef generate   chef generate cookbook cookbooks/base   Now move the  base.rb  to  default.rb  of base cookbook.   mv /workspace/chapter3/base.rb cookbooks/base/recipes/default.rb   Add  base::default  recipe to the run_list   knife node run_list add app1  recipe[base]    Apply on node1   ssh devops@node1\nsudo chef-client   It fails  because the service name for rhel/centos is  ntpd  and  not ntp  as like debian.     To overcome this we use attribute for platform specific.  We use system defined attribute  platform_family  to do this.   Example  for  ohai platform_family  is  root@ws:/workspace/myapp# ohai platform_family\n[\n   debian \n]\nroot@ws:/workspace/myapp# kitchen login\nLast login: Thu May  4 05:50:20 2017 from 172.17.0.1\n[kitchen@9af3a004e202 ~]$ ohai platform_family\n[2017-05-04T05:58:19+00:00] INFO: The plugin path /etc/chef/ohai/plugins\ndoes not exist. Skipping...\n[\n   rhel \n]\n[kitchen@9af3a004e202 ~]$ logout\nConnection to localhost closed.\nroot@ws:/workspace/myapp#   Now let us create a create a  default attribute  file for base cookbook using  chef generate   chef generate attribute cookbooks/base default   Now add the following content to attribute file  Path:  cookbooks/base/attributes/default.rb   case node['platform_family']\nwhen 'rhel'\n  default['ntp']['service'] = 'ntpd'\nelse\n  default['ntp']['service'] = 'ntp'\nend   Call the attributes in  cookbooks/base/recipes/default.rb  recipe   service node['ntp']['service'] do\n  action [ :start, :enable ]\nend   Now apply again using kitchen   ssh devop@node1\nsudo chef-client   It is successful now and service is started based on platform.   Nano Project  - Add some tests for recipes in base cookbook for different platform.", 
            "title": "Platform Specific cookbooks"
        }, 
        {
            "location": "/07_data_driven_cookbooks_attr_templates/#templates", 
            "text": "A cookbook template is an Embedded Ruby (ERB) template that is used to dynamically generate static text files.  Templates are great way to manage configuration files for different environment.  ERB or ERUBIS  Contains text with dynamic ruby code  Uses tags to mark dynamic code  ERB Tags  Code wrapped in  % %  or  % -%  is a statement that is evaluated.  Code wrapped in  %= %  is code that is evaluated and the result is placed into the file.  Harcoded strings dont have to be wrapped in erb tags if they are constant, but Ruby code must be wrapped in erb tags if you want the result of that code to go into your file.", 
            "title": "Templates"
        }, 
        {
            "location": "/07_data_driven_cookbooks_attr_templates/#templatize-motd", 
            "text": "Generate  motd  template for  base cookbook .   chef generate template cookbooks/base motd   Add the following content to the template file  motd.erb .  Path:  cookbooks/base/templates/default/motd.erb   This server is a property of  %= node['org']['name'] % \n\n      SYSTEM INFO:\n\n       HOSTNAME   :  %= node['hostname'] % \n       IP ADDRESS :  %= node['ipaddress'] % \n       MEMORY     :  %= node['memory']['total'] %    Now add organization name as a user defined attribute in  attribute file  Path:  cookbooks/base/attributes/default.rb   default['org']['name'] =  XYZ Inc.    Complete attribute  default.rb  of  base cookbook  is as follows   case node['platform_family']\nwhen 'rhel'\n  default['ntp']['service'] = 'ntpd'\nelse\n  default['ntp']['service'] = 'ntp'\nend\n\ndefault['org']['name'] =  XYZ Inc.    Now add template resource to the  cookbooks/base/recipes/default.rb  recipe file.   template '/etc/motd' do\n  source 'motd.erb'\n  owner 'root'\n  group 'root'\n  mode  0644\nend   Apply using  kitchen converge .", 
            "title": "Templatize MOTD"
        }, 
        {
            "location": "/07_data_driven_cookbooks_attr_templates/#attributes-precedence", 
            "text": "Declaring attributes in various places takes precedence one over another.     Let us take an example of declaring port as follows     Now let us define organization name in recipe file, before calling attribute in any resource of a recipe.  Path:  cookbooks/base/recipes/default.rb   node.default['org']['name'] =  School of Devops    Complete recipe  default.rb  of  base cookbook  is as follows   user 'deploy' do\n  uid 5001\n  home '/home/deploy'\n  action :create\n  password '$1$Ze1eJK3R$j5I0NRP5WxbZAaeXcfYW7/'\nend\n\nuser 'dojo' do\n  action :remove\nend\n\npackage 'ntp' do\n  action :install\nend\n\npackage ['tree', 'unzip', 'wget'] do\n  action :install\nend\n\npackage 'git'\n\nservice node['ntp']['service'] do\n  action [ :start, :enable ]\nend\n\nnode.default['org']['name'] =  School of Devops Inc \n\ntemplate '/etc/motd' do\n  source 'motd.erb'\n  owner 'root'\n  group 'root'\n  mode  0644\nend   Now apply using  kitchen converge", 
            "title": "Attributes Precedence"
        }, 
        {
            "location": "/07_data_driven_cookbooks_attr_templates/#templatizing-tomcat-cookbook-lab-exercise", 
            "text": "Generate a  tomcat.conf.erb  template for tomcat cookbook.   chef generate template cookbooks/tomcat tomcat.conf   Generate a  default.rb  attribute for tomcat cookbook.   chef generate attribute cookbooks/tomcat default   Add the following content to attribute file.  Path:  /workspace/myapp/cookbooks/tomcat/attributes/default.rb   default['tomcat']['user'] = 'tomcat'\ndefault['tomcat']['group'] = 'tomcat'\ndefault['tomcat']['config'] = '/etc/tomcat/tomcat.conf'\ndefault['tomcat']['packages'] = [ 'tomcat', 'tomcat-webapps' ]\ndefault['tomcat']['service'] = 'tomcat'\ndefault['tomcat']['user'] = 'tomcat'\ndefault['tomcat']['group'] = 'tomcat'\ndefault['tomcat']['java_home'] = '/usr/lib/jvm/jre'\ndefault['tomcat']['catalina_home'] = '/usr/share/tomcat'\ndefault['tomcat']['java_opts'] = '-Xms32m -Xmx64m -XX:MaxPermSize=64M  \\\n-Djava.security.egd=file:/dev/./urandom'   Add the below content to  tomcat.conf.erb  template.  Path:  /workspace/myapp/cookbooks/tomcat/templates   TOMCAT_CFG_LOADED= 1 \n\nJAVA_HOME= %= node['tomcat']['java_home'] % \nJAVA_OPTS= %= node['tomcat']['java_opts'] % \n\nCATALINA_BASE= /usr/share/tomcat \nCATALINA_HOME= %= node['tomcat']['catalina_home'] % \nJASPER_HOME= /usr/share/tomcat \nCATALINA_TMPDIR= /var/cache/tomcat/temp \n\nTOMCAT_USER= %= node['tomcat']['user'] % \n\nSECURITY_MANAGER= false \n\nSHUTDOWN_WAIT= 30 \n\nSHUTDOWN_VERBOSE= false \n\nCATALINA_PID= /var/run/tomcat.pid    Now update  tomcat::config  recipe as mentioned below  Path:  /workspace/myapp/cookbooks/tomcat/recipes/config.rb   template node['tomcat']['config'] do\n  source 'tomcat.conf.erb'\n  owner node['tomcat']['user']\n  group node['tomcat']['group']\n  mode '0644'\n  action :create\n  notifies :restart,  service[#{node['tomcat']['service']}] , :delayed\nend    Apply using  kitchen converge    Now change the values of  JAVA_OPTS  in attribute file and then apply again for verifying the changes using template and attribute.    Also verify using  kitchen login  and run  ps auwwx  command.", 
            "title": "Templatizing Tomcat Cookbook (LAB Exercise)"
        }, 
        {
            "location": "/08_customizing_community_cookbooks/", 
            "text": "Customizing Community Cookbooks\n\n\nCustomizing Strategy\n\n\n\n\nFork - Directly use the community cookbook by forking the upstream cookbook.\n\n\nWrapper - Create a wrapper cookbook which calls the community cookbook and customize it, by creating a dependency.\n\n\n\n\nCreating myhaproxy cookbook\n\n\n\n\nGenerate a cookbook called \nmyhaproxy\n inside \nsysfoo\n.\n\n\n\n\ncd /workspace/chapter8/sysfoo/\nchef generate cookbook cookbooks/myhaproxy\n\n\n\n\n\n\nAdd dependency in \nmyhaproxy/metadata.rb\n\n\n\n\ndepends 'haproxy', '= 1.6.7'\n\n\n\n\n\n\nNow add the wrapper content to include and modify \nhaproxy\n cookbook by adding the following in \nmyhaproxy/recipes/default.rb\n\n\n\n\nnode.default['haproxy']['members'] = [{\n     \nhostname\n =\n \nnode1\n,\n     \nipaddress\n =\n \nnode1\n,\n     \nport\n =\n 8080,\n     \nssl_port\n =\n 8080\n   },\n   {\n    \nhostname\n =\n \nnode2\n,\n    \nipaddress\n =\n \nnode2\n,\n    \nport\n =\n 8080,\n    \nssl_port\n =\n 8080\n  }]\n\n\nnode.default['haproxy']['incoming_port'] = 8080\n\n\ninclude_recipe 'haproxy::default'\n\n\n\n\nResolve Dependency and Bootstrapping\n\n\n\n\nUse berkshelf to resolve dependency of \nmyhaproxy\n cookbook.\n\n\nUpload the cookbook to server.\n\n\nNow bootstrap \nnode4\n by naming it as \nlb\n and adding the following run_list\n\n\nbase\n\n\nchef-client\n\n\nmyhaproxy\n\n\n\n\nVerifying Load Balancer\n\n\n\n\nAfter bootstrapping visit http://ip:8084 to check the load Balancer.\n\n\nIt is 8084 because the host port 8080 is mapped to 8084.", 
            "title": "Customizing Community Cookbooks"
        }, 
        {
            "location": "/08_customizing_community_cookbooks/#customizing-community-cookbooks", 
            "text": "", 
            "title": "Customizing Community Cookbooks"
        }, 
        {
            "location": "/08_customizing_community_cookbooks/#customizing-strategy", 
            "text": "Fork - Directly use the community cookbook by forking the upstream cookbook.  Wrapper - Create a wrapper cookbook which calls the community cookbook and customize it, by creating a dependency.", 
            "title": "Customizing Strategy"
        }, 
        {
            "location": "/08_customizing_community_cookbooks/#creating-myhaproxy-cookbook", 
            "text": "Generate a cookbook called  myhaproxy  inside  sysfoo .   cd /workspace/chapter8/sysfoo/\nchef generate cookbook cookbooks/myhaproxy   Add dependency in  myhaproxy/metadata.rb   depends 'haproxy', '= 1.6.7'   Now add the wrapper content to include and modify  haproxy  cookbook by adding the following in  myhaproxy/recipes/default.rb   node.default['haproxy']['members'] = [{\n      hostname  =   node1 ,\n      ipaddress  =   node1 ,\n      port  =  8080,\n      ssl_port  =  8080\n   },\n   {\n     hostname  =   node2 ,\n     ipaddress  =   node2 ,\n     port  =  8080,\n     ssl_port  =  8080\n  }]\n\n\nnode.default['haproxy']['incoming_port'] = 8080\n\n\ninclude_recipe 'haproxy::default'", 
            "title": "Creating myhaproxy cookbook"
        }, 
        {
            "location": "/08_customizing_community_cookbooks/#resolve-dependency-and-bootstrapping", 
            "text": "Use berkshelf to resolve dependency of  myhaproxy  cookbook.  Upload the cookbook to server.  Now bootstrap  node4  by naming it as  lb  and adding the following run_list  base  chef-client  myhaproxy", 
            "title": "Resolve Dependency and Bootstrapping"
        }, 
        {
            "location": "/08_customizing_community_cookbooks/#verifying-load-balancer", 
            "text": "After bootstrapping visit http://ip:8084 to check the load Balancer.  It is 8084 because the host port 8080 is mapped to 8084.", 
            "title": "Verifying Load Balancer"
        }, 
        {
            "location": "/09_deployment/", 
            "text": "Nano Project: Deploy Sysfoo on Tomcat\n\n\nSo far you have learnt to write cookbooks, recipes and how to create data driven cookbooks. Now that you have setup tomcat, you have been\ntasked to write code to deploy a java web application to tomcat server. This application can be pulled from the CI server e.g. Jenkins, CircleCI etc. And the deployment should be automated.\n\n\nSteps :\n\n\n\n\nCreate a GitHub account\n\n\nClone sample java webapp repo from https://github.com/schoolofdevops/sample-webapp\n\n\nCreate a CircleCI Account https://circleci.com and integrate with your github sample-webapp project, setup the build\n\n\nWrite a deploy recipe with chef, add it to run list and test deploy.\n\n\n\n\nDeploy Recipe Specs:\n\n\nCreate a sysfoo::deploy recipe with the following specifications,\n  * Your recipe should download the artifact (warfile) from circle CI\n   (e.g https://5-94848332-gh.circle-artifacts.com/0/tmp/circle-artifacts.uqT2VIZ/sysfoo.war)\n  * The above URL should be parameterized. Updating the URL using an attribute should deploy the new version.\n  * The resource which downloads the artifact should be idempotent. It should not download the same file again if chef-client is run, unless its a new version of the artifact.\n\n  * The downloaded artifact  should be copied it to the webapps directory of tomcat as app.war.  In this example, it would be /usr/share/tomcat/webapps/sysfoo.war\n  * The previous version of the application, if available, should be deleted (path: /usr/share/tomcat/webapps/sysfoo)\n  * Tomcat needs to be restarted whenever a new version of artifact s deployed.", 
            "title": "Deploying Sysfoo App"
        }, 
        {
            "location": "/09_deployment/#nano-project-deploy-sysfoo-on-tomcat", 
            "text": "So far you have learnt to write cookbooks, recipes and how to create data driven cookbooks. Now that you have setup tomcat, you have been\ntasked to write code to deploy a java web application to tomcat server. This application can be pulled from the CI server e.g. Jenkins, CircleCI etc. And the deployment should be automated.", 
            "title": "Nano Project: Deploy Sysfoo on Tomcat"
        }, 
        {
            "location": "/09_deployment/#steps", 
            "text": "Create a GitHub account  Clone sample java webapp repo from https://github.com/schoolofdevops/sample-webapp  Create a CircleCI Account https://circleci.com and integrate with your github sample-webapp project, setup the build  Write a deploy recipe with chef, add it to run list and test deploy.", 
            "title": "Steps :"
        }, 
        {
            "location": "/09_deployment/#deploy-recipe-specs", 
            "text": "Create a sysfoo::deploy recipe with the following specifications,\n  * Your recipe should download the artifact (warfile) from circle CI\n   (e.g https://5-94848332-gh.circle-artifacts.com/0/tmp/circle-artifacts.uqT2VIZ/sysfoo.war)\n  * The above URL should be parameterized. Updating the URL using an attribute should deploy the new version.\n  * The resource which downloads the artifact should be idempotent. It should not download the same file again if chef-client is run, unless its a new version of the artifact. \n  * The downloaded artifact  should be copied it to the webapps directory of tomcat as app.war.  In this example, it would be /usr/share/tomcat/webapps/sysfoo.war\n  * The previous version of the application, if available, should be deleted (path: /usr/share/tomcat/webapps/sysfoo)\n  * Tomcat needs to be restarted whenever a new version of artifact s deployed.", 
            "title": "Deploy Recipe Specs:"
        }, 
        {
            "location": "/10_roles/", 
            "text": "Roles\n\n\n\n\nTo create a roles in chef DSL we need to create a folder named \nroles\n inside the repo directory \n(myapp/roles)\n.\n\n\nA sample role file consist of the following,\n\n\nName\n\n\nDescription\n\n\nRun_list\n\n\n\n\nAttributes\n\n\n\n\n\n\nA sample role file is as follows \nroles/sample.rb\n\n\n\n\n\n\nname \nstarter\n\ndescription \nAn example Chef role\n\nrun_list \nrecipe[starter]\n\noverride_attributes({\n  \nstarter_name\n =\n \nstarter\n,\n})\n\n\n\n\nCreating Roles for myapp\n\n\n\n\nNow create a roles for application and load_balancer.\n\n\nmyapp/roles/app.rb\n\n\n\n\nmyapp/roles/lb.rb\n\n\n\n\n\n\nAdd the following content to app.rb\n\n\n\n\n\n\nname \napp\n\ndescription \nTomcat Application Server\n\nrun_list \nrecipe[base]\n, \nrecipe[tomcat]\n, \nrecipe[chef-client]\n, \nrecipe[sysfoo::deploy]\n\noverride_attributes({\n  \nchef_client\n =\n { \ninterval\n =\n 120,\n                     \nsplay\n =\n 30\n                   }\n})\n\n\n\n\n\n\nAdd the following content to lb.rb\n\n\n\n\nname \nlb\n\ndescription \nLoad Balancer\n\nrun_list \nrecipe[base]\n, \nrecipe[myhaproxy]\n, \nrecipe[chef-client]\n\noverride_attributes({\n  \nchef_client\n =\n { \ninterval\n =\n 60,\n                     \nsplay\n =\n 20\n                   }\n})\n\n\n\n\nUploading Roles to Chef Server\n\n\n\n\nFrom the \nmyapp\n directory using knife command upload the roles from file \napp.rb\n and \nlb.rb\n\n\n\n\nknife role from file app.rb lb.rb\n\n\n\n\nApplying Roles to Run_list\n\n\n\n\nNow replace the existing run_list of nodes with roles.\n\n\nAdd run_list to node1\n\n\n\n\nknife node run_list set app1 \nrole[app]\n\n\n\n\n\n\n\nAdd run_list to node2\n\n\n\n\nknife node run_list set app2 \nrole[app]\n\n\n\n\n\n\n\nAdd run_list to node4\n\n\n\n\nknife node run_list set lb \nrole[lb]\n\n\n\n\n\nRun chef-client on all nodes\n\n\n\n\nNow we need to run \nchef-client\n on all nodes.\n\n\nWe can do this by passing a \nsudo chef-client\n command to all nodes using knife as follows\n\n\n\n\nknife ssh \n*:*\n -x devops -a ipaddress \nsudo chef-client\n\n\n\n\n\n\n\nVerify the changes using \nps aux | grep chef-client\n on all nodes to find the time interval.\n\n\n\n\nknife ssh \n*:*\n -x devops -a ipaddress \nps aux | grep chef-client", 
            "title": "Roles"
        }, 
        {
            "location": "/10_roles/#roles", 
            "text": "To create a roles in chef DSL we need to create a folder named  roles  inside the repo directory  (myapp/roles) .  A sample role file consist of the following,  Name  Description  Run_list   Attributes    A sample role file is as follows  roles/sample.rb    name  starter \ndescription  An example Chef role \nrun_list  recipe[starter] \noverride_attributes({\n   starter_name  =   starter ,\n})", 
            "title": "Roles"
        }, 
        {
            "location": "/10_roles/#creating-roles-for-myapp", 
            "text": "Now create a roles for application and load_balancer.  myapp/roles/app.rb   myapp/roles/lb.rb    Add the following content to app.rb    name  app \ndescription  Tomcat Application Server \nrun_list  recipe[base] ,  recipe[tomcat] ,  recipe[chef-client] ,  recipe[sysfoo::deploy] \noverride_attributes({\n   chef_client  =  {  interval  =  120,\n                      splay  =  30\n                   }\n})   Add the following content to lb.rb   name  lb \ndescription  Load Balancer \nrun_list  recipe[base] ,  recipe[myhaproxy] ,  recipe[chef-client] \noverride_attributes({\n   chef_client  =  {  interval  =  60,\n                      splay  =  20\n                   }\n})", 
            "title": "Creating Roles for myapp"
        }, 
        {
            "location": "/10_roles/#uploading-roles-to-chef-server", 
            "text": "From the  myapp  directory using knife command upload the roles from file  app.rb  and  lb.rb   knife role from file app.rb lb.rb", 
            "title": "Uploading Roles to Chef Server"
        }, 
        {
            "location": "/10_roles/#applying-roles-to-run_list", 
            "text": "Now replace the existing run_list of nodes with roles.  Add run_list to node1   knife node run_list set app1  role[app]    Add run_list to node2   knife node run_list set app2  role[app]    Add run_list to node4   knife node run_list set lb  role[lb]", 
            "title": "Applying Roles to Run_list"
        }, 
        {
            "location": "/10_roles/#run-chef-client-on-all-nodes", 
            "text": "Now we need to run  chef-client  on all nodes.  We can do this by passing a  sudo chef-client  command to all nodes using knife as follows   knife ssh  *:*  -x devops -a ipaddress  sudo chef-client    Verify the changes using  ps aux | grep chef-client  on all nodes to find the time interval.   knife ssh  *:*  -x devops -a ipaddress  ps aux | grep chef-client", 
            "title": "Run chef-client on all nodes"
        }, 
        {
            "location": "/11_search/", 
            "text": "Search\n\n\n\n\nSearch is used to run a query on chef-server.\n\n\nTo search for nodes, roles, environment and data bags.\n\n\nSearch patterns include exact, wildcards and range.\n\n\nSearch can be included within recipe or using knife CLI.\n\n\n\n\nReplacing myhaproxy recipe\n\n\n\n\nInstead of adding the additional web servers manually to the list of haproxy, we can use search inside recipe to perform that.\n\n\nNow we can change the default recipe as follows\n\n\nPath: \nmyapp/cookbooks/myhaproxy/recipes/default.rb\n\n\n\n\nall_web_nodes = search(\nnode\n, \nrole:app\n)\n\nmembers = [ ]\n\nall_web_nodes.each do | web_node |\n\n     member = {\n        'hostname' =\n web_node['hostname'],\n        'ipaddress' =\n web_node['ipaddress'],\n        'port' =\n 8080,\n        'ssl_port' =\n 8080\n    }\n\n  members.push(member)\nend\n\nnode.default['haproxy']['members'] = members\n\nnode.default['haproxy']['incoming_port'] = 8080\n\ninclude_recipe 'haproxy::default'\n\n\n\n\n\n\nNow before uploading this to chef server we will change the version of cookbook by adding the version in metadata.\n\n\nChange the version in \nmyapp/cookbooks/myhaproxy/metadata.rb\n from \n0.1.0\n to \n0.2.0\n.\n\n\nUpload the myhaproxy cookbook.\n\n\n\n\nVerifying Search Functionality\n\n\n\n\nNow bootstrap node3 as web server using the role app.\n\n\nBefore bootstrap watch the haproxy.cfg file in \nnode4(Load Balancer)\n, which will be getting updated for every 60 seconds defined by chef-client process.\n\n\n\n\nwatch -n 1 tail /etc/haproxy/haproxy.cfg\n\n\n\n\n\n\nNow bootstrap node3 from workstation,\n\n\n\n\nknife bootstrap node3 -x devops --sudo -N \napp3\n -r \nrole[app]\n\n\n\n\n\n\n\nAfter a minute we can see the entry of new web-server \nnode3\n added to the load balancer configuration file.", 
            "title": "Search"
        }, 
        {
            "location": "/11_search/#search", 
            "text": "Search is used to run a query on chef-server.  To search for nodes, roles, environment and data bags.  Search patterns include exact, wildcards and range.  Search can be included within recipe or using knife CLI.", 
            "title": "Search"
        }, 
        {
            "location": "/11_search/#replacing-myhaproxy-recipe", 
            "text": "Instead of adding the additional web servers manually to the list of haproxy, we can use search inside recipe to perform that.  Now we can change the default recipe as follows  Path:  myapp/cookbooks/myhaproxy/recipes/default.rb   all_web_nodes = search( node ,  role:app )\n\nmembers = [ ]\n\nall_web_nodes.each do | web_node |\n\n     member = {\n        'hostname' =  web_node['hostname'],\n        'ipaddress' =  web_node['ipaddress'],\n        'port' =  8080,\n        'ssl_port' =  8080\n    }\n\n  members.push(member)\nend\n\nnode.default['haproxy']['members'] = members\n\nnode.default['haproxy']['incoming_port'] = 8080\n\ninclude_recipe 'haproxy::default'   Now before uploading this to chef server we will change the version of cookbook by adding the version in metadata.  Change the version in  myapp/cookbooks/myhaproxy/metadata.rb  from  0.1.0  to  0.2.0 .  Upload the myhaproxy cookbook.", 
            "title": "Replacing myhaproxy recipe"
        }, 
        {
            "location": "/11_search/#verifying-search-functionality", 
            "text": "Now bootstrap node3 as web server using the role app.  Before bootstrap watch the haproxy.cfg file in  node4(Load Balancer) , which will be getting updated for every 60 seconds defined by chef-client process.   watch -n 1 tail /etc/haproxy/haproxy.cfg   Now bootstrap node3 from workstation,   knife bootstrap node3 -x devops --sudo -N  app3  -r  role[app]    After a minute we can see the entry of new web-server  node3  added to the load balancer configuration file.", 
            "title": "Verifying Search Functionality"
        }, 
        {
            "location": "/12_environments/", 
            "text": "Creating Configuration Profiles with Environments\n\n\nIn this lab we are going to use chef's environment primitive to,\n  * Create different configuration profiles. Setup environment specific configurations.\n  * Set cookbook versioning constraints. Define cookbook versions to be used in each environment. This way you could limit your experimentation with your own dev env without affecting rest of the environments.\n  * Provide isolation in combination with search.  \n\n\nMaking search more specific with environments\n\n\nIn the previous module, we learnt about search, and even incorporated it to auto discover app servers from load balancer. However with the current configurations, the search results will return list of all app servers, irrespective of the environment. We need to make this search specific to the node's environment.\n\n\n\n\nLets update \nmyhaproxy\n recipe accordingly\n\n\nPath: \ncookbooks/myhaproxy/recipes/default.rb\n\n\n\n\nUpdate the line which uses search to,\n\n\nall_web_nodes = search(\nnode\n, \nrole:app AND chef_environment:#{node.chef_environment}\n)\n\n\n\n\nAlso update the version in the metadata.\n\n\nPath: \ncookbooks/myhaproxy/metadata.rb\n\n\nversion '0.3.0'\n\n\n\n\nUpload the cookbook\n\n\nknife cookbook upload myhaproxy                                                                                            \n\n\n\n\nCreating a prod environment\n\n\n\n\nCreate a environment file\n\n\nPath: \nsysfoo/environments/prod.rb\n\n\n\n\nname \nprod\n\ndescription \nProduction Environment\n\ncookbook \nmyhaproxy\n, \n= 0.3.0\n\ndefault_attributes({\n  \ntomcat\n =\n { \ndeploy\n  =\n {\n                 \nurl\n =\n 'https://9-94848332-gh.circle-artifacts.com/0/tmp/circle-artifacts.9U1rN6X/sysfoo.war'}\n              }\n})\n\n\n\n\nUploading and exploring environment\n\n\nknife environment from file prod.rb   \n\nknife environment show prod\n\n\n\n\nBringing nodes into the environment\n\n\nFrom node4 keep watching the haproxy.cfg\n\n\nwatch -n 1 tail /etc/haproxy/haproxy.cfg\n\n\n\n\nLets bring in two nodes into prod env\n\n\nknife node environment set app1 prod\nknife node environment set app2 prod                                                                                         \n\n\n\n\nKeep watching the haproxy config. It should take the two nodes off as the load balancer still belongs to \n_default env\n.\n\n\nLets bring load balancer into the prod env\n\n\nknife node environment set lb prod\n\n\n\n\nSee as the LB limits itself to serve only to the app servers in its own environment.\n\n\nYou should also see two differnt versions of the applications running in the two environments vz \nproduction\n and \n_default\n.", 
            "title": "Environments"
        }, 
        {
            "location": "/12_environments/#creating-configuration-profiles-with-environments", 
            "text": "In this lab we are going to use chef's environment primitive to,\n  * Create different configuration profiles. Setup environment specific configurations.\n  * Set cookbook versioning constraints. Define cookbook versions to be used in each environment. This way you could limit your experimentation with your own dev env without affecting rest of the environments.\n  * Provide isolation in combination with search.", 
            "title": "Creating Configuration Profiles with Environments"
        }, 
        {
            "location": "/12_environments/#making-search-more-specific-with-environments", 
            "text": "In the previous module, we learnt about search, and even incorporated it to auto discover app servers from load balancer. However with the current configurations, the search results will return list of all app servers, irrespective of the environment. We need to make this search specific to the node's environment.   Lets update  myhaproxy  recipe accordingly  Path:  cookbooks/myhaproxy/recipes/default.rb   Update the line which uses search to,  all_web_nodes = search( node ,  role:app AND chef_environment:#{node.chef_environment} )  Also update the version in the metadata.  Path:  cookbooks/myhaproxy/metadata.rb  version '0.3.0'  Upload the cookbook  knife cookbook upload myhaproxy", 
            "title": "Making search more specific with environments"
        }, 
        {
            "location": "/12_environments/#creating-a-prod-environment", 
            "text": "Create a environment file  Path:  sysfoo/environments/prod.rb   name  prod \ndescription  Production Environment \ncookbook  myhaproxy ,  = 0.3.0 \ndefault_attributes({\n   tomcat  =  {  deploy   =  {\n                  url  =  'https://9-94848332-gh.circle-artifacts.com/0/tmp/circle-artifacts.9U1rN6X/sysfoo.war'}\n              }\n})", 
            "title": "Creating a prod environment"
        }, 
        {
            "location": "/12_environments/#uploading-and-exploring-environment", 
            "text": "knife environment from file prod.rb   \n\nknife environment show prod", 
            "title": "Uploading and exploring environment"
        }, 
        {
            "location": "/12_environments/#bringing-nodes-into-the-environment", 
            "text": "From node4 keep watching the haproxy.cfg  watch -n 1 tail /etc/haproxy/haproxy.cfg  Lets bring in two nodes into prod env  knife node environment set app1 prod\nknife node environment set app2 prod                                                                                           Keep watching the haproxy config. It should take the two nodes off as the load balancer still belongs to  _default env .  Lets bring load balancer into the prod env  knife node environment set lb prod  See as the LB limits itself to serve only to the app servers in its own environment.  You should also see two differnt versions of the applications running in the two environments vz  production  and  _default .", 
            "title": "Bringing nodes into the environment"
        }
    ]
}